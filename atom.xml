<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[easypi's blog]]></title>
  <link href="http://easypi.github.com/atom.xml" rel="self"/>
  <link href="http://easypi.github.com/"/>
  <updated>2013-04-28T17:23:10+08:00</updated>
  <id>http://easypi.github.com/</id>
  <author>
    <name><![CDATA[厚之成]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[机器学习之线性回归]]></title>
    <link href="http://easypi.github.com/blog/2013/04/28/linear-regression-of-machine-regression/"/>
    <updated>2013-04-28T16:56:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/04/28/linear-regression-of-machine-regression</id>
    <content type="html"><![CDATA[<p>机器学习是一种广泛应用的技术，其中有监督的学习是其主要内容。本文介绍一类简单的有监督学习算法：线性回归。线性回归是最基础的有监督学习算法，本文将从理论介绍，算法实现，应用实例三个方面对该算法进行介绍。</p>

<!-- more -->

<h2 id="section">介绍</h2>

<p>有监督学习方法通常具有三个要素：假设模型、优化目标(cost function)、算法。</p>

<h3 id="section-1">假设模型</h3>

<p>线性回归的建设模型用 $h(x)$ 表示：</p>

<script type="math/tex; mode=display"> h(x) = \sum_{i=0}^{n}{\theta_i x_i} = \theta^T x </script>

<p>其中 $\theta$ 称为参数或权重， $x$ 为输入或特征，$n$ 为特征个数（不包括$x_0$）</p>

<h3 id="section-2">优化目标</h3>

<p>线性回归的优化目标是使cost function最小，其中cost function 用 $J(\theta)$ 表示， 为</p>

<script type="math/tex; mode=display"> J(\theta) = \frac{1}{2} \sum_{i=1}^{n} (h_{\theta}(x^{(i)})-y^{(i)})^2 </script>

<p>这个函数叫做普通最小二乘函数（ordinary least squares）。</p>

<h3 id="section-3">算法</h3>

<ol>
  <li>
    <p>梯度下降法</p>

    <p>可以使用梯度下降法来求得最小二乘函数的最小值，梯度下降法表示为</p>

<script type="math/tex; mode=display"> \theta_j := \theta_j - \alpha  \frac{\partial}{\partial \theta_j} J(\theta) </script>

    <p>其中$\theta$开始与初始猜测值，并且更新同时作用于所有参数$j= 0, … n$。其中$\alpha$为学习速度，控制每步更新的幅度。</p>

    <p>对于最小二乘函数，可求得其偏导数为：</p>

<script type="math/tex; mode=display"> \frac{\partial}{\partial \theta_j} J(\theta) = (h_\theta (x)-y)x_j</script>

    <p>因此对于一个训练样本，更新规则为：</p>

<script type="math/tex; mode=display">\theta_j := \theta_j + \alpha(y^{(i)} - h_\theta (x^{(i)})) x_j ^{(i)} </script>

    <p>这就是所谓的最小二乘法（Least Mean Squares, LMS）,也叫Widrow-Hoff法。</p>

    <p>当训练样本多于一个时，由此引出两种方法可以处理多个样本的样本集：批梯度下降法(batch gradient descent)和随机梯度下降法或增量梯度下降法(stochastic gradient descent or incremental gradient descent).</p>

    <p>1.1. 批梯度下降法</p>

    <p>Repeat until convergence {</p>

    <p><script type="math/tex"> \theta_j := \theta_j + \alpha \frac{1}{m} \sum_{i=1}^{m} (y^{(i)} - h_\theta (x^{(i)})) x_j ^{(i)} </script> (for every $j$)</p>

    <p>}</p>

    <p>该方法每次更新基于所有$m$个训练样本，由于$J$是一个凸二次函数，因此没有局部最小值，只有唯一一个全局最小值，因此该方法保证收敛到（学习速率$\alpha$不太大）全局最小点。缺点是当$m$太大时，每次更新都基于全部样本，成本太高，因此有了随机梯度下降法。</p>

    <p>1.2. 随机梯度下降法</p>

    <p>Loop {</p>

    <p>for i=1 to m, {</p>

    <p><script type="math/tex">\theta_j := \theta_j + \alpha ( y^{(i)} - h_\theta (x^{(i)})) x_j ^{(i)}</script> (for every $j$)</p>

    <p>}</p>

    <p>}</p>

    <p>该算法每次更新基于一个训练样本，因此也叫做增量梯度下降法，当训练样本特别大时，应用批梯度下降法成本太高时可以使用该方法。该方法的缺点是：通常该方法只能找到全局最小点的近似值，当到达最小点附近时可能发生振荡而永远找不到全局最小值，但实际应用中最小值附近的近似值已经够用了。（PS. 实际使用中随着算法的运行可以减小学习速度$\alpha$的值到0附近，来避免一直振荡从而实现收敛）</p>
  </li>
  <li>
    <p>标准方程法(normal equations)</p>

    <p>梯度下降是一种求得$J$最小值的方法，是一种迭代的方法。另一种方法是一种直接求得解析解的方法，叫做标准方程法。数学中我们知道，导数为零时出现极值，对于$J$极值为最小值，为我们所求。基于该思想，通过构造矩阵，可以直接求出$J$最小时的$\theta$值。不推导直接给出结果：</p>

<script type="math/tex; mode=display"> \theta = (X^T X)^{-1} X^T Y</script>

    <p>其中$X$ 为$m-by-n+1$的矩阵，$(x^{(i)})^T$ 为第$i$个训练样本:</p>

<script type="math/tex; mode=display"> X = \left[ \begin{array}{c} (x^{(1)})^T \\ (x^{(2)})^T \\ ... \\ (x^{(m)})^T \end{array} \right]</script>

    <p>其中$Y$ 为$m$维的向量，$y^{(i)}$ 为第$i$个目标值</p>

<script type="math/tex; mode=display"> Y = \left[ \begin{array}{c} y^{(1)} \\ y^{(2)} \\ ... \\ y^{(m)} \end{array} \right]</script>

    <p>使用该方法可以一步计算出所求参数值，不需迭代。但是当矩阵很大时，求矩阵的逆代价较高，而且如果选取的特征是线性相关的，则矩阵的逆不存在，需要使用伪逆代替。</p>

    <p>综上所述，当特征较少且相互独立时可以使用标准方程的方法求得参数，否则使用梯度下降法。使用梯度下降法时如果训练样本较少，使用批梯度下降法，得到全局最小点；否则使用随机梯度下降法，得到近似全局最小点。</p>
  </li>
</ol>

<h3 id="section-4">相关技巧</h3>

<p>在使用线性回归模型时，有两个需要注意的技巧：特征归一化（feature scaling）和学习速度$\alpha$的设定。</p>

<ol>
  <li>
    <p>特征归一化</p>

    <p>当线性回归模型中有多个特征时，如果其中某个特征的取值范围相比其它特征的取值范围大很多，那么这个特征对最后的假设模型中容易产生比较大的影响，为了获得较好的学习效果，需要使各特征的取值范围相似，这个过程称为归一化。其中最直接的一种方法是平均标准化（mean normalization）：</p>

<script type="math/tex; mode=display"> x_j = \frac{x_j - \mu_j}{s_j}</script>

    <p>其中$x_j$为特征，$\mu_j$为特征的平均值，$s_j$为特征的取值范围，通过这一过程，所有特征的取值范围被规范到$[-0.5,0.5]$ 的范围内。</p>
  </li>
  <li>
    <p>学习速度设定</p>

    <p>学习速度$\alpha$决定算法收敛的快慢，当其取值小时，能够保证收敛但收敛太慢；当取值大时，可能出现震荡而不收敛。因此需要选取合适的学习速度。但没有方法直接选取最好的学习速度，只能是收敛性和收敛速度二者的权衡，需要在实验中观察结果来选取合适的$\alpha$值。</p>
  </li>
</ol>

<h2 id="section-5">代码实现</h2>

<p><code>linear_regression.py</code></p>

<pre><code>import numpy as np
import pylab as pl

def mean_normalization(X_set):
    m, n = X_set.shape


    for j in range(1,n):
        x_j = X_set[:,j]
        x_j_mean = np.mean(x_j)
        x_j_range = np.max(x_j) - np.min(x_j)

        x_j = (x_j - x_j_mean) / (x_j_range + np.spacing(1))
        X_set[:,j] = x_j

    return X_set

def normal_equation(X, y, learning_rate = 0):
    theta = np.linalg.pinv(X.T * X) * X.T * y
    return theta

def batch_gradient(X, y, learning_rate = 1e-1):
    epsilon = 1e-3 # converged if error is less than epsilon
    max_iter = 1e4 # max iterator number of loop

    m, n = X.shape
        
    theta = np.asmatrix( np.zeros([n,1]) )
    ite = 0
    abs_err = list()
    abs_err.append(1e5)

    while ite &lt; max_iter and abs_err[-1] &gt; epsilon: 
        for j in range(n):
            theta[j] = theta[j] + learning_rate * 1/m * ( (y - X * theta).T * X[:,j] )

        abs_err.append( np.linalg.norm( X * theta - y ) )
        ite += 1
        print str(ite) + " abs_err: " + str(abs_err[-1])

    return theta

def stochastic_gradient(X, y, learning_rate = 1e-2):
    epsilon = 1e-3 # converged if error is less than epsilon
    max_iter = 1e3 # max iterator number of loop

    m, n = X.shape
    theta = np.asmatrix( np.zeros([n,1]) )
    ite = 0
    abs_err = list()
    abs_err.append(1e5)

    while ite &lt; max_iter and abs_err[-1] &gt; epsilon: 
        for i in range(m):
            for j in range(n):
                theta[j] = theta[j] + learning_rate * ( y[i,:] - X[i,:] * theta) * X[i,j]
       
        ite += 1
        abs_err.append( np.linalg.norm( X.dot(theta) - y ) )
        print str(ite) + " abs_err: " + str(abs_err[-1])


    return theta
    
class LinearRegression(object):
    """Linear regression model:"""
    def __init__(self, feature_scaling = None):
        self.feature_scaling = feature_scaling
        self.theta = None

    def train(self, X_train, y_train, algorithm = normal_equation, learning_rate = 0.01):

        if X_train.shape[0] != y_train.shape[0]:
            print "different size of X and y in training set"
        
        m, n = X_train.shape

        # feature scaling
        if self.feature_scaling is not None:
            X_train = self.feature_scaling(X_train)

        # training parameter
        self.theta = algorithm(X_train, y_train, learning_rate)

        print self.theta
        
    def predict(self, X_test):
        # feature scaling
        if self.feature_scaling is not None:
            X_test= self.feature_scaling(X_test)

        y_test = self.theta.T * X_test
        return y_test
</code></pre>

<h2 id="section-6">例子</h2>

<p>给出两个线性回归的例子，数据可在本文的源码一节找到。</p>

<ol>
  <li>
    <p>一元线性回归例子：</p>

<script type="math/tex; mode=display"> h(x) = \theta_0 + \theta_1 * x_1 </script>

    <p>对此线性函数找到合适的参数。</p>

    <p><code>linear_regression.py</code></p>

    <pre><code> def main():
     datasets = np.genfromtxt('data.txt', delimiter=',')
     X_train = np.matrix (datasets[:, :-1])
     m, n = X_train.shape
     X_train = np.c_[np.ones([m,1]), X_train]
     y_train = np.matrix (datasets[:, -1]).T

     lr = LinearRegression(feature_scaling=None)
     lr.train(X_train, y_train, algorithm = batch_gradient)

     pl.scatter(X_train[:,1], y_train)
     pl.plot(X_train[:,1], X_train * lr.theta, 'r')
     pl.show()



 if __name__ == '__main__':
     main()
</code></pre>

    <p>回归结果如图</p>

    <p><img src="http://easypi.github.com/images/MachineLearning/LinearRegression/image.png" alt="result" /></p>
  </li>
  <li>
    <p>多元线性回归例子</p>

<script type="math/tex; mode=display"> h(x) = \theta_0 + \theta_1 * x_1 + \theta_2 * x_2 </script>

    <p>对此二元函数，找到合适的参数。对比实验，来比较不同梯度下降算法的性能。</p>

    <p><img src="http://easypi.github.com/images/MachineLearning/LinearRegression/batch_gradient.png" alt="批梯度下降法" />
 <img src="http://easypi.github.com/images/MachineLearning/LinearRegression/stochastic_gradient.png" alt="随机梯度下降法" /></p>

    <p>通过二图比较可知，随机梯度下降法算法学习速度快,能够收敛到一个近似的全局最小点。当数据量大时优势尤为明显。 </p>
  </li>
</ol>

<h2 id="section-7">总结</h2>

<p>本文介绍来线性回归的原理以及实现，并通过实例给出回归结果及算法性能比较。通过本文可以了解机器学习中的线性回归算法，对于实际问题是否使用该算法还需要模型选择的知识，对于使用该算法的问题，还需要研究如何选择特征才能够达到好的学习性能，这些问题将在以后的文章中介绍。</p>

<h2 id="section-8">源码</h2>

<p>可在github上找到本文的<a href="https://github.com/easypi/MachineLearning.git">程序源码以及数据文件</a></p>

<h2 id="section-9">参考</h2>

<ul>
  <li><a href="http://cs229.stanford.edu/">stanford machine learning cs229</a></li>
  <li><a href="https://www.coursera.org/course/ml">Coursera: machine learning by Andrew Ng</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在windows 7 上部署已有的中文octopress博客]]></title>
    <link href="http://easypi.github.com/blog/2013/04/22/octopress-on-windows/"/>
    <updated>2013-04-22T16:59:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/04/22/octopress-on-windows</id>
    <content type="html"><![CDATA[<p>之前在ubuntu下搭建了octopress的博客，现在想在实验室的windows 7上也搭建起来。网上的文章多为在windows搭建新的octopress博客，本文则是将已有的octopress博客部署到windows 7的环境下。</p>

<!--more-->

<h2 id="section">安装依赖</h2>

<ol>
  <li><a href="http://git-scm.com/">安装git</a></li>
  <li><a href="http://rubyinstaller.org/downloads/">安装ruby for windows</a>,本文使用<a href="http://rubyforge.org/frs/download.php/76798/rubyinstaller-1.9.3-p392.exe">ruby 1.9.3-p392</a>,注意设置环境变量。</li>
  <li><a href="http://rubyinstaller.org/downloads/">安装ruby develop kit</a>, 本文使用<a href="https://github.com/downloads/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe">DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</a> 并解压到文件夹如<code>c:\RubyDevKit</code></li>
  <li>
    <p>cmd中运行命令</p>

    <pre><code> cd C:/RubyDevKit
 ruby dk.rb init
 ruby dk.rb install
</code></pre>
  </li>
</ol>

<h2 id="octopress">安装octopress</h2>

<ol>
  <li>
    <p>创建博客文件夹，如<code>d:\myblog</code></p>
  </li>
  <li>
    <p>克隆自己的octopress到本地， <code>username 改为自己的</code></p>

    <pre><code> git clone -b source https://github.com/username/username.github.com.git octopress
 cd octopress 
 git clone https://github.com/username/username.github.com.git _deploy #下载_deploy版本（用于发布）
</code></pre>
  </li>
  <li>
    <p>安装octopress</p>

    <pre><code> gem install bundler
 bundle install
</code></pre>
  </li>
  <li>
    <p>解决中文支持问题。由于windows 7的默认字符编码为gbk，而octopress支持的是utf8。因此需要解决二者之间的冲突，否则对中文博客会产生错误。 最简单的解决方法如下：</p>

    <p>4.1 打开git bash， 运行<code>cd </code>到用户根文件夹</p>

    <p>4.2 查看目录下是否存在<code>.bash_profile</code>,如果不存在则使用<code>touch .bash_profile</code>新建该文件.</p>

    <p>4.3 编辑<code>.bash_profile</code>，添加如下两行</p>

    <pre><code>     export   LC_ALL=zh_CN.UTF-8
     export   LANG=zh_CN.UTF-8
</code></pre>

    <p>4.4 重启git bash， 切换到octopress目录，生成博客并预览观察是否部署成功</p>

    <pre><code>     rake generate
     rake preview
</code></pre>
  </li>
  <li>
    <p>（可选）latex数学公式支持。如果需要博客支持数学公式，则进行该步，否则已完成。</p>

    <p>5.1 安装<code>kramdown</code>包</p>

    <pre><code>     gem install kramdown
</code></pre>

    <p>5.2 修改<code>_config.yml</code>设定，找到octopress目录下动<code>_config.yml</code>文件，找到markdown，并将<code>rdiscount</code>修改为<code>kramdown</code>.</p>

    <p>5.3 将mathjax引入博客系统。在<code>/source/_includes/custom/head.html</code>中添加如下内容</p>

    <pre><code>     &lt;!-- mathjax config similar to math.stackexchange --&gt;

     &lt;script type="text/x-mathjax-config"&gt;
       MathJax.Hub.Config({
         tex2jax: {
           inlineMath: [ ['$','$'], ["\\(","\\)"] ],
           processEscapes: true
         }
       });
     &lt;/script&gt;

     &lt;script type="text/x-mathjax-config"&gt;
         MathJax.Hub.Config({
           tex2jax: {
             skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
           }
         });
     &lt;/script&gt;

     &lt;script type="text/x-mathjax-config"&gt;
         MathJax.Hub.Queue(function() {
             var all = MathJax.Hub.getAllJax(), i;
             for(i=0; i &lt; all.length; i += 1) {
                 all[i].SourceElement().parentNode.className += ' has-jax';
             }
         });
     &lt;/script&gt;

     &lt;script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;
     &lt;/script&gt;
</code></pre>

    <p>5.4 在博客中添加如下公式，查看效果</p>

    <pre><code>     $$
     \begin{align*}
       &amp; \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
       = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
       &amp; (x_1, \ldots, x_n) \left( \begin{array}{ccc}
           \phi(e_1, e_1) &amp; \cdots &amp; \phi(e_1, e_n) \\
           \vdots &amp; \ddots &amp; \vdots \\
           \phi(e_n, e_1) &amp; \cdots &amp; \phi(e_n, e_n)
         \end{array} \right)
       \left( \begin{array}{c}
           y_1 \\
           \vdots \\
           y_n
         \end{array} \right)
     \end{align*}
     $$
</code></pre>

    <p>效果为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

 \begin{align*}
   & \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
   = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
   & (x_1, \ldots, x_n) \left( \begin{array}{ccc}
       \phi(e_1, e_1) & \cdots & \phi(e_1, e_n) \\
       \vdots & \ddots & \vdots \\
       \phi(e_n, e_1) & \cdots & \phi(e_n, e_n)
     \end{array} \right)
   \left( \begin{array}{c}
       y_1 \\
       \vdots \\
       y_n
     \end{array} \right)
 \end{align*}
  %]]&gt;</script>
  </li>
</ol>

<h2 id="section-1">博客发布流程记录</h2>

<p>由于只更改了git bash的配置文件，因此博客发布都在git bash下进行。</p>

<ol>
  <li>
    <p>新建博客–&gt;编辑 –&gt; 生成 –&gt; 预览 –&gt; 发布</p>

    <pre><code> rake new_post['title'] 
 # edit markdown file
 rake generate
 rake preview
 rake deploy
</code></pre>
  </li>
  <li>
    <p>备份源码到source分支</p>

    <pre><code> git add .
 git commit -m "commit comments"
 git push origin source
</code></pre>
  </li>
</ol>

<h2 id="section-2">参考</h2>
<ul>
  <li><a href="http://stb.techelex.com/setup-octopress-on-windows7/">Setup Octopress on Windows7</a></li>
  <li><a href="http://www.cnblogs.com/hangxin1940/archive/2012/03/19/2806438.html">为自己现有的github octopress配置环境</a></li>
  <li><a href="http://sinosmond.github.io/blog/2012/03/12/install-and-deploy-octopress-to-github-on-windows7-from-scratch/">在 Windows7 下从头开始安装部署 Octopress</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：Python语言实现之行为型模式]]></title>
    <link href="http://easypi.github.com/blog/2013/04/02/design-pattern-in-python-behavioral-ones/"/>
    <updated>2013-04-02T18:02:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/04/02/design-pattern-in-python-behavioral-ones</id>
    <content type="html"><![CDATA[<p>行为型模式对类和对象怎样交互和分配职责进行描述，不仅描述对象或类的模式，还描述它们之间的通信模式。按范围分为行为类模式和行为对象模式，其中类模式使用继承机制在类间分配职责，包括Interpreter和Template Method两种；而对象模式通过对象复合机制实现，包括包括Chain of Responsibility、Command、Iterator、Mediator、Memento、Observer、State、Strategy和Visitor模式。本文将分别介绍。</p>

<!--more-->

<h2 id="chain-of-responsibility--">Chain of Responsibility (职责链) 模式</h2>

<h3 id="section">定义</h3>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</p>

<h3 id="section-1">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/chain_of_responsibility.png" alt="UML图" /></p>

<h3 id="section-2">参与者</h3>
<ul>
  <li>Handler：定义一个处理请求的接口</li>
  <li>ConcreteHandler：处理它负责的请求，可访问它的后继者，如果可处理该请求，就处理之；否则将请求转发给它的后继者。</li>
  <li>Client：向链上的具体处理者对象提交请求。</li>
</ul>

<h3 id="section-3">代码实现</h3>
<ul>
  <li>
    <p><code>handler.py</code></p>

    <pre><code>  class Handler(object):
      def set_successor(self, successor):
          self.successor = successor
      def handle_request(self, request):
          pass

  class ConcreteHandler1(Handler):
      def handle_request(self, request):
          if request &gt;= 0 and request &lt;= 10:
              print "Concrete Handler 1 handled the request " + str(request)
          elif self.successor is not None:
              self.successor.handle_request(request)
          else:
              print "no successor to handle it"

  class ConcreteHandler2(Handler):
      def handle_request(self, request):
          if request &gt;= 10:
              print "Concrete Handler 2 handled the request " + str(request)
          elif self.successor is not None:
              self.successor.handle_request(request)
          else:
              print "no successor to handle it"
</code></pre>
  </li>
  <li>
    <p><code>client.py</code></p>

    <pre><code>  from handler import *

  h1 = ConcreteHandler1()
  h2 = ConcreteHandler2()
  h1.set_successor(h2)

  for request in range(1,20,2):
      h1.handle_request(request)
</code></pre>
  </li>
</ul>

<h3 id="section-4">适用性</h3>
<ul>
  <li>当有多个对象都可以处理一个请求，但哪个对象处理该请求运行时刻自动确定时，使用该模式。</li>
  <li>可以在不确定接收者的情况下，向多个对象中的一个提交请求</li>
  <li>可以修改处理请求的结构，增加了给对象指派职责的灵活性。</li>
</ul>

<hr />

<h2 id="command-">Command（命令） 模式</h2>

<h3 id="section-5">定义</h3>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；将请求排队或记录请求日志，以及支持可撤销的操作。</p>

<h3 id="section-6">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/command.png" alt="UML图" /></p>

<h3 id="section-7">参与者</h3>
<ul>
  <li>Command：声明执行操作的接口</li>
  <li>ConcreteCommand：将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute</li>
  <li>Client：创建一个具体命令对象并设定它的接收者。</li>
  <li>Invoker：要求该命令执行这个请求</li>
  <li>Receiver：知道如何实施与执行一个请求相关的操作。任何类都可以作为一个接收者。</li>
</ul>

<h3 id="section-8">代码实现</h3>
<ul>
  <li>
    <p><code>command.py</code></p>

    <pre><code>  class Command(object):
      def __init__(self, receiver):
          self.receiver = receiver    
      def execute(self):
          pass

  class ConcreteCommand(Command):
      def execute(self):
          self.receiver.action()

  class Invoker(object):
      def set_command(self, command):
          self.command = command

      def execute_command(self):
          self.command.execute()

  class Receiver(object):
      def action(self):
          print "action!"
</code></pre>
  </li>
  <li>
    <p><code>client.py</code></p>

    <pre><code>  from command import * 

  r = Receiver()
  c = ConcreteCommand(r)
  i = Invoker()
  i.set_command(c)
  i.execute_command()
</code></pre>
  </li>
</ul>

<h3 id="section-9">适用性</h3>
<ul>
  <li>当希望容易的设计一个命令队列，并容易的将命令计入日志</li>
  <li>希望容易实现对请求的撤销与重做。</li>
  <li>将请求操作的对象鱼执行操作的对象分割开。</li>
</ul>

<hr />

<h2 id="interpreter-">Interpreter（解释器） 模式</h2>

<h3 id="section-10">定义</h3>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。是类行为型模式。</p>

<h3 id="section-11">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/interpreter.png" alt="UML图" /></p>

<h3 id="section-12">参与者</h3>
<ul>
  <li>AbstractExpression：声明一个抽象的解释操作，这个接口为抽象语法树中的所有节点共享。</li>
  <li>TerminalExpression：终结符表达式，句子中的终结符需要该类的一个实例。</li>
  <li>NonterminalExpression：非终结符表达式，文法中的每一条规则都需要一个该类，对文中的非终结符实现解释操作。</li>
  <li>Context：包括解释器之外的一些全局信息。</li>
  <li>Client：构建该文法定义语言中的一个特定的句子的抽象语法树，调用解释操作。</li>
</ul>

<h3 id="section-13">代码实现</h3>
<ul>
  <li>
    <p><code>interpreter.py</code></p>

    <pre><code>  class AbstractExpression(object):
      def interpret(self, context):
          pass

  class TerminalExpression(AbstractExpression):
      def interpret(self, context):
          print "terminal interpret"

  class NonterminalExpression(AbstractExpression):
      def interpret(self, context):
          print "nonterminal interpret"

  class Context(object):
      def __init__(self, arg_string):
          self.arg_string = arg_string

  def main():
      c = Context("context text")
      sentence = []
      sentence.append(NonterminalExpression())
      sentence.append(TerminalExpression())
      sentence.append(NonterminalExpression())   

      for expression in sentence:
          expression.interpret(c)

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-14">适用性</h3>
<ul>
  <li>当语言需要解释执行，并且可将该语言的句子表示为抽象语法树时，可以使用。</li>
  <li>将复杂语法转换形式，使用简单的句法构建复杂的结构。</li>
</ul>

<hr />

<h2 id="iterator-">Iterator（迭代器） 模式</h2>

<h3 id="section-15">定义</h3>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>

<h3 id="section-16">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/command.png" alt="UML图" /></p>

<h3 id="section-17">参与者</h3>
<ul>
  <li>Iterator：迭代器定义访问和遍历元素的接口。</li>
  <li>ConcreteIterator：具体迭代器实现迭代器接口，对该聚合遍历时跟踪当前位置。</li>
  <li>Aggregate：聚合定义创建相应迭代器对象的接口。</li>
  <li>ConcreteAggregate：具体聚合实现创建相应迭代器的接口，返回具体迭代器的一个适当实例。</li>
</ul>

<h3 id="section-18">代码实现</h3>
<ul>
  <li>
    <p><code>iterator.py</code></p>

    <pre><code>  class Iterator(object):
      def first(self):
          pass
        
      def next(self):
          pass

      def is_done(self):
          pass

      def current_itern(self):
          pass

  class ConcreteIterator(Iterator):
      def __init__(self, aggregate):
          self.aggregate = aggregate
          self.current = 0

      def first(self):
          return self.aggregate.get(0)
      def next(self):
          self.current += 1  
          if self.current &lt; self.aggregate.count():
              return self.aggregate.get(self.current)

      def is_done(self):
          if self.current &gt;= self.aggregate.count():
              return True
          else:
              return False

      def current_itern(self):
          return self.aggregate.get(self.current)

  class Aggregate(object):
      def create_iterator(self):
          pass

  class ConcreteAggregate(Aggregate):
      def __init__(self):
          self.list = []

      def get(self, idx):
          return self.list[idx]

      def set(self, idx, value):
          self.list.insert(idx, value)

      def count(self):
          return len(self.list)

      def create_iterator(self):
          return ConcreteIterator(self)


  def main():
      a = ConcreteAggregate()
      a.set(0,"no.1")
      a.set(1,"no.2")
      a.set(2,"no.3")

      it = a.create_iterator()

      while not it.is_done():
          print it.current_itern() + " do something"
          it.next()

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-19">适用性</h3>
<ul>
  <li>希望访问一个聚合对象的内容而无需暴露它的内部表示</li>
  <li>支持对聚合对象的多种遍历</li>
  <li>为遍历不同的聚合结构提供一个统一的接口 </li>
</ul>

<hr />

<h2 id="mediator-">Mediator（中介者） 模式</h2>

<h3 id="section-20">定义</h3>
<p>用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。</p>

<h3 id="section-21">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/mediator.png" alt="UML图" /></p>

<h3 id="section-22">参与者</h3>
<ul>
  <li>Mediator：中介者定义一个接口用于与各同事对象通信。</li>
  <li>ConcreteMediator：具体中介者通过协调各同事对象实现协作行为，了解并维护它的各个同事</li>
  <li>Colleague：抽象同事类</li>
  <li>ConcreteColleague：具体同事类，每个同事知道它的中介者对象，不知道其他同事，需要通信时与中介者通信。</li>
</ul>

<h3 id="section-23">代码实现</h3>
<ul>
  <li>
    <p><code>mediator.py</code></p>

    <pre><code>  class Mediator(object):
      def send(self, colleague, message):
          pass

  class Colleague(object):
      def __init__(self, mediator):
          self.mediator = mediator
     
  class ConcreteMediator(Mediator):
      def set_colleague(self, colleague1, colleague2):
          self.colleague1 = colleague1
          self.colleague2 = colleague2

      def send(self, colleague, message):
          if self.colleague1 is colleague:
              self.colleague2.notify(message)
          elif self.colleague2 is colleague:
              self.colleague1.notify(message)
          else:
              print "no such colleague"

  class ConcreteColleague1(Colleague):
      def send(self, message):
          self.mediator.send(self, message)

      def notify(self, message):
          print "concrete colleague 1 get message: " + message

  class ConcreteColleague2(Colleague):
      def send(self, message):
          self.mediator.send(self, message)

      def notify(self, message):
          print "concrete colleague 2 get message: " + message

  def main():
      cm = ConcreteMediator()
      cc1 = ConcreteColleague1(cm)
      cc2 = ConcreteColleague2(cm)

      cm.set_colleague(cc1, cc2)

      cc1.send("hello cc2")
      cc2.send("what's up? cc1")

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-24">适用性</h3>
<ul>
  <li>一组对象以定义良好但是复杂的方式进行通信，产生的依赖关系结构混乱且难以理解。</li>
  <li>定制一个分布在多个类中的行为，而又不希望太多的子类</li>
  <li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li>
</ul>

<hr />

<h2 id="memento-">Memento（备忘录） 模式</h2>

<h3 id="section-25">定义</h3>
<p>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p>

<h3 id="section-26">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/memento.png" alt="UML图" /></p>

<h3 id="section-27">参与者</h3>
<ul>
  <li>Memento：备忘录存储Originator对象的内部状态，防止Originator以外的其他对象访问备忘录。它只有两个接口，Caretaker只能看到其窄接口，只能将备忘传给其他对象；originator看到宽接口，可以访问其内部状态以返回到保存的状态。理想情况下只允许生成备忘的原发器访问该备忘。</li>
  <li>Originator：原发器创建一个备忘录，用以记录当前时刻的内部状态。使用备忘录恢复内部状态。</li>
  <li>Caretaker：负责保存好备忘录，不能对备忘录的内容进行操作或检查。</li>
</ul>

<h3 id="section-28">代码实现</h3>
<ul>
  <li>
    <p><code>memento.py</code></p>

    <pre><code>  class Originator(object):
      def __init__(self):
          self.state = " "

      def change_state(self, state):
          self.state = state

      def show(self):
          print self.state

      def set_memento(self, memento):
          self.state = memento.state

      def create_memento(self):
          return Memento(self.state)

  class Memento(object):
      def __init__(self, state):
          self.state = state

      def get_state(self):
          return self.state


  class Craetaker(object):
      def set_memento(self, memento):
          self.memento = memento
      def get_memento(self):
          return self.memento

  def main():
      o = Originator()
      o.change_state("state 1")
      o.show()
      c = Craetaker()
      c.set_memento(o.create_memento())

      o.change_state("state 2")
      o.show()

      o.set_memento(c.get_memento())
      o.show()

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-29">适用性</h3>
<ul>
  <li>必须保存某一对象的某一时刻状态，以后需要时可以恢复到先前的状态。但是不希望让其他对象直接得到这些状态，不希望破坏对象的封装性。</li>
</ul>

<hr />

<h2 id="observer-">Observer（观察者） 模式</h2>

<h3 id="section-30">定义</h3>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>

<h3 id="section-31">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/observer.png" alt="UML图" /></p>

<h3 id="section-32">参与者</h3>
<ul>
  <li>Subject：目标知道它的观察者，可以有任何数量的观察者，提供注册和删除观察者对象的接口。</li>
  <li>Observer：为目标发生改变时需获得通知的对象定义更新接口。 </li>
  <li>ConcreteSubject：将有关状态存入各个ConcreteObserver对象，当它的状态发生改变时，向它的各个观察者发出通知</li>
  <li>ConcreteObserver：维护指向ConcreteSubject对象的引用，存储有关状态，这些状态应保持与目标的状态一致，并实现Observer的自身状态更新接口。</li>
</ul>

<h3 id="section-33">代码实现</h3>
<ul>
  <li>
    <p><code>observer.py</code></p>

    <pre><code>  class Subject(object):
      def __init__(self):
          self.observers = []

      def attach(self, observer):
          self.observers.append(observer)

      def detach(self, observer):
          self.observers.remove(observer)

      def notify(self):
          for observer in self.observers:
              observer.update()

  class Observer(object):
      def update(self):
          pass

  class ConcreteSubject(Subject):
      def __init__(self):
          super(ConcreteSubject, self).__init__()
          self.state = ""

      def set_state(self, state):
          self.state = state

      def get_state(self):
          return self.state

  class ConcreteObserver(Observer):
      def __init__(self, subject):
          self.subject = subject
          self.state = ""

      def set_subject(self, subject):
          self.subject = subject

      def get_subject(self):
          return self.subject

      def update(self):
          self.state = self.subject.get_state()
          print self.state

  def main():
      s = ConcreteSubject()
     
      c1 = ConcreteObserver(s)
      c2 = ConcreteObserver(s)
      s.attach(c1)
      s.attach(c2)

      s.set_state("I'm back!")
      s.notify()

      s.set_state("I'm leaving!")
      s.notify()


  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-34">适用性</h3>
<ul>
  <li>当一个抽象对象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在独立的对象中以使它们可以各自独立的改变和复用。</li>
  <li>当一个对象的改变需要同时改变其他对象，而又不知道具体有多少对象有待改变时。或者是当对象不是紧耦合的，即不能假定其他对象是谁时。</li>
</ul>

<hr />

<h2 id="state-">State（状态） 模式</h2>

<h3 id="section-35">定义</h3>
<p>允许一个对象在其内部状态改变时改变它的行为，看起来似乎修改了它的类。</p>

<h3 id="section-36">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/state.png" alt="UML图" /></p>

<h3 id="section-37">参与者</h3>
<ul>
  <li>Context：定义客户感兴趣的接口，维护一个ConcreteState子类的实例，这个实例定义了当前的状态。</li>
  <li>State：定义一个接口以封装与context的一个特定状态相关的行为。</li>
  <li>ConcreteState：每一个子类实现一个与Context的一个状态相关的行为。</li>
</ul>

<h3 id="section-38">代码实现</h3>
<ul>
  <li>
    <p><code>state.py</code></p>

    <pre><code>  class State(object):
      def handle(self, context):
          pass

  class ConcreteState1(State):
      def handle(self, context):
          next_state = ConcreteState2()
          context.set_state(next_state)

  class ConcreteState2(State):
      def handle(self, context):
          next_state = ConcreteState1()
          context.set_state(next_state)

  class Context(object):
      def __init__(self, state):
          self.state = state

      def set_state(self, state):
          self.state = state
          print "self.state is " + self.state.__class__.__name__

      def get_state(self):
          return self.state

      def request(self):
          self.state.handle(self)
            
  def main():
      s1 = ConcreteState1()
      c = Context(s1)
      c.request()
      c.request()
      c.request()
      c.request()

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-39">适用性</h3>
<ul>
  <li>当一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变行为，希望把状态和行为分割开来。</li>
  <li>当一个操作中有大量的分支和条件语句时，且这些分支依赖于对象的状态。该模式将不同状态下的分支分别放入一个独立的类中，可以根据自身情况将对象的状态作为对象，而该对象不依赖于其他对象而独立变化。</li>
</ul>

<hr />

<h2 id="strategy-">Strategy（策略） 模式</h2>

<h3 id="section-40">定义</h3>
<p>定义一系列的算法，把他们一个一个封装起来，并且使他们可以互相替换。使算法可独立于它的客户端而变化。</p>

<h3 id="section-41">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/strategy.png" alt="UML图" /></p>

<h3 id="section-42">参与者</h3>
<ul>
  <li>Strategy：定义所有支持的算法的公共接口，Context使用这个接口调用某ConcreteStrategy定义的算法</li>
  <li>ConcreteStrategy：实现具体接口的算法类</li>
  <li>Context：用一个ConcreteStrategy来配置，维护一个对Strategy的引用，定义一个接口来让Strategy访问它的数据库。</li>
</ul>

<h3 id="section-43">代码实现</h3>
<ul>
  <li>
    <p><code>strategy.py</code></p>

    <pre><code>  class Strategy(object):
      def algorithm_interface(self):
          pass

  class ConcreteStrategy1(Strategy):
      def algorithm_interface(self):
          print "algorithm 1 "

  class ConcreteStrategy2(Strategy):
      def algorithm_interface(self):
          print "algorithm 2 "

  class ConcreteStrategy3(Strategy):
      def algorithm_interface(self):
          print "algorithm 3 "

  class Context(object):
      def __init__(self, cs):
          self.s = Strategy()
          self.s = cs

      def context_interface(self):
          self.s.algorithm_interface()

  def main():
      cs1 = ConcreteStrategy1()
      c = Context(cs1)
      c.context_interface()

      cs2 = ConcreteStrategy2()
      c = Context(cs2)
      c.context_interface()

      cs3 = ConcreteStrategy3()
      c = Context(cs3)
      c.context_interface()

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-44">适用性</h3>
<ul>
  <li>但许多相关类仅仅是行为有异。</li>
  <li>需要使用一个算法的不同变体，或定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。</li>
</ul>

<hr />

<h2 id="template-method-">Template Method（模板方法） 模式</h2>

<h3 id="section-45">定义</h3>
<p>模板方法是类行为型模式。定义一个操作中的算法和骨架，而将一些步骤延迟到子类中，该模式可以不改变一个算法的结构即可重定义该算法的某些特地步骤。</p>

<h3 id="section-46">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/template_method.png" alt="UML图" /></p>

<h3 id="section-47">参与者</h3>
<ul>
  <li>AbstractClass：定义抽象的原语操作（primitive operation），具体的子类将重新定义它们以实现一个算法的各步骤。实现一个模板方法，定义一个算法的骨架。</li>
  <li>ConcreteClass：具体实现原语操作中的特定步骤和算法</li>
</ul>

<h3 id="section-48">代码实现</h3>
<ul>
  <li>
    <p><code>template_method.py</code></p>

    <pre><code>  class AbstractClass(object):
      def primitive_operation1(self):
          pass

      def primitive_operation1(self):
          pass

      def template_method(self):
          self.primitive_operation1()
          self.primitive_operation2()
          print "!!"

  class ConcreteClass1(AbstractClass):
      def primitive_operation1(self):
          print "class 1 operation 1 "
      def primitive_operation2(self):
          print "class 1 operation 2 "

  class ConcreteClass2(AbstractClass):
      def primitive_operation1(self):
          print "class 2 operation 1 "
      def primitive_operation2(self):
          print "class 2 operation 2 "

  def main():
      c = ConcreteClass1()
      c.template_method()

      c = ConcreteClass2()
      c.template_method()

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-49">适用性</h3>
<ul>
  <li>将步骤等共同部分通过模板方法一次实现，避免重复。</li>
  <li>算法的可变部分由子类实现。</li>
</ul>

<hr />

<h2 id="visitor-">Visitor（访问者） 模式</h2>

<h3 id="section-50">定义</h3>
<p>表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类型的前提下定义作用于这些元素的新操作。</p>

<h3 id="section-51">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/visitor.png" alt="UML图" /></p>

<h3 id="section-52">参与者</h3>
<ul>
  <li>Visitor：为给对象结构中的ConcreteElement的每一个类声明一个Visit操作，该操作的名字和特征标识了发起Visit请求给访问者的那个类，使得访问者可以确定正被访问的元素的具体的类。</li>
  <li>ConcreteVisitor：实现每个Visitor声明的操作。</li>
  <li>Element：定义一个Accept操作，以一个访问者为参数。</li>
  <li>ConcreteElement：实现Accept操作，以访问者为参数。</li>
  <li>ObjectStructure：枚举它的元素，提供高层接口以允许该访问者访问它的元素。</li>
</ul>

<h3 id="section-53">代码实现</h3>
<ul>
  <li>
    <p><code>visitor.py</code></p>

    <pre><code>  class Visitor(object):
      def visit_concrete_element_a(self, concrete_element_a):
          pass
      def visit_concrete_element_b(self, concrete_element_b):
          pass

  class ConcreteVisitor1(Visitor):
      def visit_concrete_element_a(self, concrete_element_a):
          print concrete_element_a.__class__.__name__ + " is visited by " + self.__class__.__name__
      def visit_concrete_element_b(self, concrete_element_b):
          print concrete_element_b.__class__.__name__ + " is visited by " + self.__class__.__name__

  class ConcreteVisitor2(Visitor):
      def visit_concrete_element_a(self, concrete_element_a):
          print concrete_element_a.__class__.__name__ + " is visited by " + self.__class__.__name__
      def visit_concrete_element_b(self, concrete_element_b):
          print concrete_element_b.__class__.__name__ + " is visited by " + self.__class__.__name__

  class Element(object):
      def accept(self, visitor):
          pass

  class ConcreteElementA(Element):
      def accept(self, visitor):
          visitor.visit_concrete_element_a(self)
      def operation(self):
          pass

  class ConcreteElementB(Element):
      def accept(self, visitor):
          visitor.visit_concrete_element_b(self)
      def operation(self):
          pass

  class ObjectStructure(object):
      def __init__(self):
          self.elements = []

      def attach(self, element):
          self.elements.append(element)

      def detach(self, element):
          self.elements.remove(element)

      def accept(self, visitor):
          for element in self.elements:
              element.accept(visitor)

  def main():
      o = ObjectStructure()
      o.attach(ConcreteElementA())
      o.attach(ConcreteElementB())

      v1 = ConcreteVisitor1()
      v2 = ConcreteVisitor2()

      o.accept(v1)
      o.accept(v2)

  if __name__ == '__main__':
      main()
</code></pre>
  </li>
</ul>

<h3 id="section-54">适用性</h3>
<ul>
  <li>需要对一个对象的结构中的对象进行很多不同的并且不相关的操作，visitor让相关操作集中到一个类中。</li>
  <li>需要把处理从数据结构中分离出来。</li>
</ul>

<hr />
<p>### 参考
- <a href="http://book.douban.com/subject/1052241/">设计模式-可复用面向对象软件的基础</a> 
- <a href="http://book.douban.com/subject/2334288/">大话设计模式</a>
- <a href="http://docs.linuxtone.org/ebooks/Python/Thinking_In_Python.pdf">Thinking in python</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：Python语言实现之结构型模式]]></title>
    <link href="http://easypi.github.com/blog/2013/03/29/design-pattern-in-python-structual-ones/"/>
    <updated>2013-03-29T18:02:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/03/29/design-pattern-in-python-structual-ones</id>
    <content type="html"><![CDATA[<p>结构型模式涉及到如何组合类和对象以获得更大的结构。本文将给出结构型模式的定义，结构，代码实现和特点等内容。本文涉及的结构型模式包括：adapter模式，bridge模式，composite模式，decorator模式，facade模式，flyweight模式，和proxy模式。</p>

<!--more-->

<h2 id="adapter">Adapter（适配器）模式</h2>

<h3 id="section">定义</h3>
<p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>

<h3 id="section-1">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/adapter.png" alt="UML图" /></p>

<h3 id="section-2">参与者</h3>
<ul>
  <li>Target: 客户所期待的与特定领域相关的接口。</li>
  <li>Adaptee: 需要适配的类，是一个已存在的接口。</li>
  <li>Adapter：对Adaptee的接口与Target接口进行适配。</li>
  <li>Client：客户端，与复合Target接口的对象协同。</li>
</ul>

<h3 id="section-3">代码实现</h3>
<ul>
  <li>
    <p>Target类（<code>target.py</code>）</p>

    <pre><code>  class Target(object):
      def request(self):
          print "nomal request"
</code></pre>
  </li>
  <li>
    <p>Adaptee类（<code>adaptee.py</code>）</p>

    <pre><code>  class Adaptee(object):
      def specific_request(self):
          print "specific request"
</code></pre>
  </li>
  <li>
    <p>Adapter类（<code>adapter.py</code>）</p>

    <pre><code>  from target import *
  from adaptee import *

  class Adapter(Target):
      def __init__(self):
          self.myadaptee = Adaptee()

      def request(self):
          self.myadaptee.specific_request()
</code></pre>
  </li>
  <li>
    <p>客户端（<code>client.py</code>）</p>

    <pre><code>  from adapter import *

  target = Adapter()
  target.request()
</code></pre>
  </li>
</ul>

<h3 id="section-4">适用性</h3>
<ul>
  <li>想使用一个已经存在的类，而他的接口不符合你的要求时可以使用此模式。</li>
  <li>客户端代码可以统一调用同一接口，即使是对不相关或不可预见的类。</li>
</ul>

<hr />

<h2 id="bridge">Bridge（桥接）模式</h2>

<h3 id="section-5">定义</h3>
<p>将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p>

<h3 id="section-6">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/bridge.png" alt="UML图" /></p>

<h3 id="section-7">参与者</h3>
<ul>
  <li>Abstraction: 定义抽象类的接口，维护一个指向Implementor类对象的指针。</li>
  <li>RefinedAbstraction：扩充Abstraction定义的接口。</li>
  <li>Implementor: 定义实现类的接口，该接口不一定要与Abstraction的接口一致，该类接口提供基本操作，Abstraction类定义了基于这些基本操作的较高层次的操作。</li>
  <li>ConcreteImplementor：具体实现Implementor的接口。</li>
</ul>

<h3 id="section-8">代码实现</h3>
<ul>
  <li>
    <p>Implementor 类（<code>Implementor.py</code>）</p>

    <pre><code>  class Implementor(object):
      def operation_imp(self):
          pass

  class ConcreteImplementorA(Implementor):
      def operation_imp(self):
          print "ConcreteImplementorA operate"

  class ConcreteImplementorB(Implementor):
      def operation_imp(self):
          print "ConcreteImplementorB operate"
</code></pre>
  </li>
  <li>
    <p>Abstraction 类（<code>abstraction.py</code>）
      from implementor import *</p>

    <pre><code>  class Abstraction(object):
      def __init__(self):
          self.imp = Implementor()

      def set_imp(self,conc_imple):
          self.imp = conc_imple;

      def operate(self):
          self.imp.operation_imp()
</code></pre>
  </li>
  <li>
    <p>client （<code>client.py</code> ）</p>

    <pre><code>  from abstraction import *
  from implementor import *

  ab = Abstraction()
  imp = ConcreteImplementorA()
  ab.set_imp(imp)
  ab.operate()
</code></pre>
  </li>
</ul>

<h3 id="section-9">适用性</h3>

<ul>
  <li>不希望抽象与实现部分有一个固定的绑定，该模式可以在运行时刻配置抽象类的实现。</li>
  <li>希望抽象部分和实现部分都可通过子类进行扩充。该模式可以独立的对抽象与实现分别扩充。</li>
  <li>希望实现系统的多角度分类，减少各分类之间的耦合。</li>
</ul>

<hr />

<h2 id="composite">Composite（组合）模式</h2>

<h3 id="section-10">定义</h3>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。该模式使得用户对单个对象和组合对象的使用具有一致性。</p>

<h3 id="section-11">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/composite.png" alt="UML图" /></p>

<h3 id="section-12">参与者</h3>
<ul>
  <li>Component：为组合中的对象声明接口，在适当情况下实现所有类公有接口的缺省行为，声明一个用于管理Component的子组件</li>
  <li>Leaf：在组合中表示叶节点对象，叶节点没有子节点。</li>
  <li>Composite：定义有子部件的那些部件的行为，存储子部件，实现接口中与子部件有关的操作</li>
  <li>Client：通过Component接口操作组合部件对象。</li>
  <li>协作： 用户使用Component接口与组合结构中的对象进行交互，如果接受者是一个叶节点，则直接处理请求，如果接受者是Composite，它通常将请求发送给它的子部件，并执行一些辅助动作。 </li>
</ul>

<h3 id="section-13">代码实现</h3>
<ul>
  <li>
    <p>(<code>composite.py</code>）</p>

    <pre><code>  class Component(object):
      def operation(self,depth):
          pass

      def add(self, component):
          pass

      def remove(self, component):
          pass

  # Leaf
  class Leaf(Component):
      def operation(self, depth):
          print "-"*depth + "leaf"

  # Composite
  class Composite(Component):
      def __init__(self):
          self.children = []

      def operation(self, depth):
          print "-"*depth + "composite"
          for c in self.children:
              c.operation(depth+2)

      def add(self, component):
          self.children.append(component)

      def remove(self, component):
          self.children.remove(component)
</code></pre>
  </li>
  <li>
    <p>Client（<code>client.py</code>）</p>

    <pre><code>  from composite import *

  comp1 = Composite()
  comp1.add(Leaf())
  comp1.add(Leaf())

  root = Composite()
  leaf = Leaf()
  root.add(leaf)
  root.add(comp1)

  root.operation(2)

  root.remove(leaf)
  root.operation(2)
</code></pre>
  </li>
</ul>

<h3 id="section-14">适用性</h3>
<ul>
  <li>希望表达对象的部分-整体层次结构，且希望用户忽略组合对象与单个对象的不同并统一的使用组合结构中的所有对象时。</li>
  <li>使设计更加一般化，并且容易增加新的组件，客户端不需根据新组间而改变。</li>
</ul>

<hr />

<h2 id="decorator">Decorator（装饰）模式</h2>

<h3 id="section-15">定义</h3>
<p>该模式也叫Wrapper（包装器），动态的给一个对象添加一些额外的职责。就增加功能来说，该模式比生成子类更为灵活。</p>

<h3 id="section-16">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/decorator.png" alt="UML图" /></p>

<h3 id="section-17">参与者</h3>
<ul>
  <li>Component：定义一个对象接口，可以给这些对象动态的添加职责。</li>
  <li>ConcreteComponent：定义一个对象，可以给这个对象添加一些职责。</li>
  <li>Decorator：维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。</li>
  <li>ConcreteDecorator：具体的装饰对象，向组件添加职责。</li>
</ul>

<h3 id="section-18">代码实现</h3>
<ul>
  <li>
    <p>Component类（<code>component.py</code>）</p>

    <pre><code>  class Component(object):
      def operation(self):
          pass

  class ConcreteComponent(Component):
      def operation(self):
          print "concrete component operate"
</code></pre>
  </li>
  <li>
    <p>Decorator类（<code>decorator.py</code>）</p>

    <pre><code>  from component import *

  class Decorator(Component):
      def __init__(self):
          self.comp = Component()

      def set_component(self, component):
          self.comp = component

      def operation(self):
          self.comp.operation()

  class ConcreteDecoratorA(Decorator):
      def __init__(self):
          super(ConcreteDecoratorA, self).__init__()
          self.added_state = " "

      def operation(self):
          super(ConcreteDecoratorA, self).operation()
          self.added_state += "new state"
          print self.added_state

  class ConcreteDecoratorB(Decorator):
      def __init__(self):
          super(ConcreteDecoratorB, self).__init__()
        
      def operation(self):
          super(ConcreteDecoratorB, self).operation()

      def added_behavior(self):
          print "added behavior"      
</code></pre>
  </li>
  <li>
    <p>客户端（<code>client.py</code>）</p>

    <pre><code>  from decorator import *

  c = ConcreteComponent()
  d1 = ConcreteDecoratorA()
  d2 = ConcreteDecoratorB()

  d1.set_component(c)
  d2.set_component(d1)

  d2.operation()
</code></pre>
  </li>
</ul>

<h3 id="section-19">适用性</h3>
<ul>
  <li>希望不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责，比静态继承更灵活。</li>
  <li>把类的核心职责和装饰功能区分开来，去除类中重复的装饰逻辑。</li>
</ul>

<hr />

<h2 id="facade">Facade（外观）模式</h2>

<h3 id="section-20">定义</h3>
<p>为子系统中的一组接口提供一个一致的界面，该模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>

<h3 id="section-21">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/facade.png" alt="UML图" /></p>

<h3 id="section-22">参与者</h3>
<ul>
  <li>Facade：知道哪些子系统负责处理请求，将客户的请求代理给合适的子系统对象。</li>
  <li>SubSystem：实现子系统的功能，处理Facade对象指派的任务，无需Facade对象的任何信息。</li>
</ul>

<h3 id="section-23">代码实现</h3>
<ul>
  <li>
    <p>SubSystem类（<code>subsystem.py</code>）</p>

    <pre><code>  class SubSystem1(object):
      def method1(self):
          print "sub system 1 method 1"

  class SubSystem2(object):
      def method2(self):
          print "sub system 2 method 2"

  class SubSystem3(object):
      def method3(self):
          print "sub system 3 method 3"
</code></pre>
  </li>
  <li>
    <p>Facade类（<code>facade.py</code>）</p>

    <pre><code>  from subsystem import *

  class Facade(object):
      def __init__(self):
          self.sub1 = SubSystem1()
          self.sub2 = SubSystem2()
          self.sub3 = SubSystem3()

      def method_a(self):
          self.sub1.method1()
          self.sub3.method3()
          self.sub2.method2()

      def method_b(self):
          self.sub3.method3()
          self.sub2.method2()
          self.sub1.method1()
</code></pre>
  </li>
  <li>
    <p>client（<code>client.py</code>）</p>

    <pre><code>  from facade import *

  fc = Facade()
  fc.method_a()
  fc.method_b()
</code></pre>
  </li>
</ul>

<h3 id="section-24">适用性</h3>
<ul>
  <li>希望复杂的系统提供简单的接口时，从更高层次上操作组合各子系统。</li>
  <li>希望减少客户程序与抽象类的实现部分之间的依赖性，可以入facade层。</li>
</ul>

<hr />

<h2 id="flyweight">Flyweight（享元）模式</h2>

<h3 id="section-25">定义</h3>
<p>运用共享技术有效的支持大量的细粒度对象。</p>

<h3 id="section-26">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/flyweight.png" alt="UML图" /></p>

<h3 id="section-27">参与者</h3>
<ul>
  <li>Flyweight：描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。</li>
  <li>ConcreteFlyweight：实现Flyweight接口，并为内部状态增加存储空间，其对象必须是可共享的。</li>
  <li>UnsharedConcreteFlyweight：Flyweight接口使共享成为可能，但是并不强制共享。该类指那些不需要被共享的子类。</li>
  <li>FlyweightFactory：创建并管理Flyweight对象，确保合理的共享Flyweight对象。</li>
  <li>client：维持一个对Flyweight的引用，计算或存储一个或多个flyweight的内部状态。</li>
</ul>

<h3 id="section-28">代码实现</h3>
<ul>
  <li>
    <p>flyweight.py</p>

    <pre><code>  class Flyweight(object):
      def operation(self, extrainsicstate):
          pass

  class ConcreteFlyweight(Flyweight):
      def operation(self, extrainsicstate):
          print "concrete flyweight" + str(extrainsicstate)

  class UnsharedConcreteFlyweight(Flyweight):
      def operation(self, extrainsicstate):
          print "unshared concrete flyweight" + str(extrainsicstate)

  class FlyweightFactory(object):
      def __init__(self):
          self.flyweights = {}

      def get_flyweight(self, key):
          if self.flyweights.has_key(key):
              return self.flyweights[key]
          else:
              fw = ConcreteFlyweight()
              self.flyweights[key] = fw
              return fw
</code></pre>
  </li>
  <li>
    <p>client.py</p>

    <pre><code>  from flyweight import *

  extrinsicstate = 20
  f = FlyweightFactory()
  fx = f.get_flyweight("x")
  fx.operation(extrinsicstate-1)

  fy = f.get_flyweight("y")
  fy.operation(extrinsicstate-1)

  uf = UnsharedConcreteFlyweight()
  uf.operation(extrinsicstate-2)
</code></pre>
  </li>
</ul>

<h3 id="section-29">适用性</h3>
<ul>
  <li>当一个程序使用了大量的对象，造成很大的存储开销时。</li>
  <li>对象的大多数状态都可变为外部状态，如果删除外部对象则可使用较少的共享对象取代很多组对象。</li>
</ul>

<hr />

<h2 id="proxy">Proxy（代理）模式</h2>

<h3 id="section-30">定义</h3>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>

<h3 id="section-31">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/proxy.png" alt="UML图" /></p>

<h3 id="section-32">参与者</h3>
<ul>
  <li>Proxy：保存一个引用，使得代理可以访问实体，提供与Subject相同的接口，代理就可以代替实体，控制对实体的新建、存储、删除。</li>
  <li>Subject：定义Proxy与RealSubject的公用接口。</li>
  <li>RealSubject：实体类。</li>
</ul>

<h3 id="section-33">代码实现</h3>
<ul>
  <li>
    <p><code>proxy.py</code></p>

    <pre><code>  class Subject(object):
      def operation(self):
          pass

  class RealSubject(Subject):
      def operation(self):
          print "real subject operation"

  class Proxy(Subject):
      def __init__(self):
          self.rs = RealSubject()

      def operation(self):
          self.rs.operation()
</code></pre>
  </li>
  <li>
    <p><code>client.py</code> </p>

    <pre><code>  from proxy import *

  proxy = Proxy()
  proxy.operation() 
</code></pre>
  </li>
</ul>

<h3 id="section-34">适用性</h3>
<ul>
  <li>远程代理：为一个在不同地址空间的对象提供局部代表。</li>
  <li>虚代理：需要创建开销很大的对象时，通过代理存放真实对象。</li>
  <li>保护代理：控制对原来对象的访问。</li>
  <li>智能指引：代理处理附加操作</li>
</ul>

<hr />

<h2 id="section-35">几种结构型模式的讨论</h2>
<ul>
  <li>Adapter和Bridge模式都给另一对象提供了一定程度上的间接性，有利于系统的灵活性。二者不同在于Adapter主要解决已有接口之间的不匹配问题，而bridge模式则是对抽象接口和实现部分进行桥接。</li>
  <li>Composite和Decorator模式具有类似的结构图，都基于递归组合来组织可变数目的对象。但Decorator旨在不需要生成子类即可给对象添加职责；而composite则旨在构造类，重点在表示不在装饰。</li>
</ul>

<hr />
<p>### 源码
欢迎大家去github上查看<a href="https://github.com/easypi/DPython.git">本项目</a>的所有源文件。</p>

<h3 id="section-36">参考</h3>
<ul>
  <li><a href="http://book.douban.com/subject/1052241/">设计模式-可复用面向对象软件的基础</a> </li>
  <li><a href="http://book.douban.com/subject/2334288/">大话设计模式</a></li>
  <li><a href="http://docs.linuxtone.org/ebooks/Python/Thinking_In_Python.pdf">Thinking in python</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：Python语言实现之创建型模式]]></title>
    <link href="http://easypi.github.com/blog/2013/03/15/design-pattern-in-python-creational-ones/"/>
    <updated>2013-03-15T20:45:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/03/15/design-pattern-in-python-creational-ones</id>
    <content type="html"><![CDATA[<p>本文介绍设计模式中的创建型模式，包括简单工厂模式、工厂方法模式、抽象工厂模式、生成器模式、原型模式和单例模式。说明了每种模式的定义、结构、特点，并给出了使用python语言实现的代码。</p>

<!-- more -->

<h2 id="simple-factory-">simple factory 模式</h2>

<h3 id="section">定义</h3>
<p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，是由一个工厂对象决定创建出哪一种产品类的实例。</p>

<h3 id="section-1">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/simplefactory.png" alt="UML图" /></p>

<h3 id="section-2">参与者</h3>
<ul>
  <li>抽象产品（Product）：所创建产品的父类，用于描述所有实例具有的公共接口</li>
  <li>具体产品（ConcreteProduct）：所创建产品的具体类，实现公共接口，产生具体实例。</li>
  <li>简单工厂（SimpleFactory）：负责实现创建实例的内部逻辑逻辑，直接被外部调用，创建所需产品对象</li>
</ul>

<h3 id="section-3">代码实现</h3>
<ul>
  <li>
    <p>抽象产品（<code>product.py</code>）</p>

    <pre><code>  class Product(object):
      """a base class to define common interfaces"""
      def operate(self):
          pass
</code></pre>
  </li>
  <li>
    <p>具体产品（<code>concrete_product_1.py</code> &amp; <code>concrete_product_2.py</code>）</p>

    <pre><code>  from product import *
  class ConcreteProduct_1(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_1"

  from product import *
  class ConcreteProduct_2(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_2"
</code></pre>
  </li>
  <li>
    <p>简单工厂（<code>simple_factory.py</code>）</p>

    <pre><code>  from concrete_product_1 import *
  from concrete_product_2 import *

  class SimpleFactory(object):
      """SimpleFactory to create concrete pruduct"""
      def create(self,option):
          if option == "product 1":
              return ConcreteProduct_1()
          elif option == "product 2":
              return ConcreteProduct_2()
          else: 
              return None
</code></pre>
  </li>
  <li>
    <p>客户端使用示例（<code>use_sim_fac.py</code>）</p>

    <pre><code>  from simple_factory import SimpleFactory

  fac = SimpleFactory()
  product = fac.create("product 2")
  if product != None:
      product.operate()
</code></pre>
  </li>
</ul>

<h3 id="section-4">优缺点</h3>

<ul>
  <li>优点：简单工厂模式中，工厂类实现逻辑，根据外界信息决定创建哪个具体类的实例，避免客户端程序直接创建具体实例。</li>
  <li>缺点：工厂类是该模式的核心，承担了太重要的角色，工厂类能够正常工作影响全部逻辑。此外，如需增加和扩展业务时需更改工厂类，违反开放-封闭的原则。</li>
</ul>

<hr />

<h2 id="factory-method-">factory method 模式</h2>

<h3 id="section-5">定义</h3>
<p>工厂方法模式又叫做虚构造器，它定义一个用于创建对象的接口，让子类决定实例化哪一个对象。该模式使一个类的实例化延迟到其子类。</p>

<h3 id="section-6">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/factorymethod.png" alt="UML图" /></p>

<h3 id="section-7">参与者</h3>
<ul>
  <li>抽象产品（Product）：所创建产品的父类，用于描述所有实例具有的公共接口</li>
  <li>具体产品（ConcreteProduct）：所创建产品的具体类，实现公共接口，产生具体实例。</li>
  <li>抽象创建者（Creator）：声明工厂方法，返回Product类型对象。</li>
  <li>具体创建者（ConcreteCreator）：定义具体工厂方法，返回具体ConcreteProduct实例。</li>
</ul>

<h3 id="section-8">代码实现</h3>
<ul>
  <li>
    <p>产品类 （<code>product.py</code>）</p>

    <pre><code>  #  abstract product
  class Product(object):
      """a base class to define common interfaces"""
      def operate(self):
          pass

  # concrete product
  class ConcreteProduct_1(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_1"

  class ConcreteProduct_2(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_2"
</code></pre>
  </li>
  <li>
    <p>创建者类 （<code>creator.py</code>）</p>

    <pre><code>  from product import *

  # abstract creator
  class Creator(object):
      """a base creator to define factory method"""
      def create(self):
          pass

  # concrete creator
  class ConcreteCreator_1(Creator):
      """ a concrete creator to implement factory method"""
      def create(self):
          return ConcreteProduct_1()

  class ConcreteCreator_2(Creator):
      """ a concrete creator to implement factory method"""
      def create(self):
          return ConcreteProduct_2()
</code></pre>
  </li>
  <li>
    <p>客户端 （<code>client.py</code>）</p>

    <pre><code>  import random
  from product import *
  from creator import *

  # choice concrete creator manually
  mycreator = ConcreteCreator_1()
  myproduct = mycreator.create()
  myproduct.operate()

  # choice concrete creator randomly
  def genefac(n):
      for i in range(n):
          yield random.choice(Creator.__subclasses__())

  mycreators = [i() for i in genefac(10)]
  myproducts = [i.create() for i in mycreators]

  for i in myproducts:
      i.operate()
</code></pre>
  </li>
</ul>

<h3 id="section-9">优缺点</h3>
<ul>
  <li>优点：工厂方法模式将简单工厂中工厂类的逻辑交由客户端，客户端选择具体工厂类进行具体产品的实例化，当增加新的产品时，不需要更改抽象工厂类，只需实现新的具体工厂类即可，封装性和可扩展性好</li>
  <li>缺点：当应用本身逻辑简单时，相对于简单工厂方法，其编码较多，额外开销大。</li>
</ul>

<hr />

<h2 id="abstract-factory-">abstract factory 模式</h2>

<h3 id="section-10">定义</h3>
<p>抽象工厂模式，又叫kit模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。适用于具有多个产品系列的应用情况。</p>

<h3 id="section-11">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/abstractfactory.png" alt="UML图" /></p>

<h3 id="section-12">参与者</h3>
<ul>
  <li>抽象工厂（AbstractFactory）：声明一个创建抽象对象产品的操作接口。</li>
  <li>具体工厂（ConcreteFactory）: 实现创建具体产品对象的操作</li>
  <li>抽象产品（AbstractProduct）：为一类产品对象声明接口</li>
  <li>具体产品（ConcreteProduct）：定义一个将被相应工厂创建的产品对象，实现抽象产品接口</li>
  <li>客户端（Client）：仅使用由抽象工厂和抽象产品声明的接口。</li>
</ul>

<h3 id="section-13">代码实现</h3>
<ul>
  <li>
    <p>产品类(<code>product.py</code>)</p>

    <pre><code>  # abstract product A

  class AbstractProductA(object):
      def operate(self):
          pass

  # concrete product A

  class ConcreteProductA1(AbstractProductA):
      def operate(self):
          print "operate by ConcreteProductA1"

  class ConcreteProductA2(AbstractProductA):
      def operate(self):
          print "operate by ConcreteProductA2"

  # abstract product B

  class AbstractProductB(object):
      def operate(self):
          pass

  # concrete product B

  class ConcreteProductB1(AbstractProductB):
      def operate(self):
          print "operate by ConcreteProductB1"

  class ConcreteProductB2(AbstractProductB):
      def operate(self):
          print "operate by ConcreteProductB2"
</code></pre>
  </li>
  <li>
    <p>工厂类(<code>factory.py</code>)</p>

    <pre><code>  from product import *

  # abstract factory

  class AbstractFactory(object):
      def create_product_a(self):
          pass
      def create_product_b(self):
          pass

  # concrete factory

  class ConcreteFactory1(AbstractFactory):
      def create_product_a(self):
          return ConcreteProductA1()
      def create_product_b(self):
          return ConcreteProductB1()

  class ConcreteFactory2(AbstractFactory):
      def create_product_a(self):
          return ConcreteProductA2()
      def create_product_b(self):
          return ConcreteProductB2()
</code></pre>
  </li>
  <li>
    <p>客户端(<code>client.py</code>)</p>

    <pre><code>  import random
  from product import *
  from factory import *

  # choice concrete factory manually
  fac = ConcreteFactory1()
  prod = fac.create_product_a()
  prod.operate()


  # choice concrete factory randomly
  def genfac(n):
      for i in range(n):
          yield random.choice(AbstractFactory.__subclasses__())

  facs = [i() for i in genfac(10)]


  prods = []
  [prods.extend([i.create_product_a(), i.create_product_b()]) for i in facs]

  for i in prods:
      i.operate()
</code></pre>
  </li>
</ul>

<h3 id="section-14">优缺点</h3>
<ul>
  <li>优点：该模式方便改变产品系列，只改变具体工厂就可以配置不同的产品系列。</li>
  <li>缺点：使用该模式增加新的产品时，由于抽象工厂定义了所有可生产产品的集合，因此需要更改所有工厂类以实现增加产品的目的，开销较大。</li>
</ul>

<hr />

<h2 id="builder-">builder 模式</h2>

<h3 id="section-15">定义</h3>
<p>生成器模式将一个复杂对象的创建过程与它的表示分离，使得同样的创建过程可以创建不同的表示。</p>

<h3 id="section-16">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/builder.png" alt="UML图" /></p>

<h3 id="section-17">参与者</h3>
<ul>
  <li>具体产品（Product）：被构造的具体产品，定义组成部件的类，由ConcreteBuilder调用接口进行具体装配。</li>
  <li>抽象生成器（Builder）：为创建具体产品对象的各个部件指定抽象接口。</li>
  <li>具体生成器（ConcreteBuilder）：定义抽象生成器的创建部件的接口，并提供一个检索具体产品的接口。</li>
  <li>指挥者（Director）：构建使用生成器接口的对象，定义构建的标准流程。</li>
</ul>

<h3 id="section-18">代码实现</h3>
<ul>
  <li>
    <p>产品类(<code>product.py</code>)</p>

    <pre><code>  class Product(object):
      def __init__(self):
          self.parts = "I hava these parts: "

      def add(self, part):
          self.parts += part

      def show(self):
          print self.parts
</code></pre>
  </li>
  <li>
    <p>生成器类（<code>builder.py</code>）</p>

    <pre><code>  from product import *

  # abstract builder
  class Builder(object):
      def build_part_a(self):
          pass
      def build_part_b(self):
          pass

  # concrete builder
  class ConcreteBuilder1(Builder):
      def __init__(self):
          self.product = Product()

      def build_part_a(self):
          self.product.add("1_part_a, ")

      def build_part_b(self):
          self.product.add("1_part_b, ")

      def get_result(self):
          return self.product

  class ConcreteBuilder2(Builder):
      def __init__(self):
          self.product = Product()

      def build_part_a(self):
          self.product.add("2_part_a, ")

      def build_part_b(self):
          self.product.add("2_part_b, ")

      def get_result(self):
          return self.product
</code></pre>
  </li>
  <li>
    <p>指挥者类(<code>director.py</code>)</p>

    <pre><code>  from builder import *

  class Director(object):
      def construct(self, builder):
          builder.build_part_a()
          builder.build_part_b()
</code></pre>
  </li>
  <li>
    <p>客户端(<code>client.py</code>)</p>

    <pre><code>  from builder import *
  from director import *

  mydirector = Director()
  mybuilder1 = ConcreteBuilder1()
  mybuilder2 = ConcreteBuilder2()

  mydirector.construct(mybuilder1)
  mydirector.construct(mybuilder2)

  prod1 = mybuilder1.get_result()
  prod2 = mybuilder2.get_result()

  prod1.show()
  prod2.show()
</code></pre>
  </li>
</ul>

<h3 id="section-19">适用性</h3>
<p>该模式适用于当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时，且允许被构造的对象有不同的表示时。它可以使构造代码与表示代码分离，通过传递不同的生成器可以改变不同的表示。相比于抽象工厂模式，二者均可建立复杂的产品对象，但侧重点不同，生成器模式侧重一步一步构造复杂产品，而抽象工厂则侧重多个系列产品（复杂或是简单的）对象的构造。</p>

<hr />

<h2 id="prototype-">prototype 模式</h2>

<h3 id="section-20">定义</h3>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>

<h3 id="section-21">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/prototype.png" alt="UML图" /></p>

<h3 id="section-22">参与者</h3>
<ul>
  <li>抽象原型（Prototype）：声明一个克隆自身的接口。</li>
  <li>具体原型（ConcretePrototype）：实现克隆自身的操作。</li>
  <li>客户端（Client）：让一个原型克隆自身返回一个新的对象。</li>
</ul>

<h3 id="section-23">代码实现</h3>

<ul>
  <li>
    <p>原型类（<code>prototype.py</code>）</p>

    <pre><code>  import copy

  # abstract prototype
  class Prototype(object):
      def clone(self):
          pass

  # concrete prototype
  class ConcretePrototype1(Prototype):
      def clone(self):
          return copy.copy(self)

  class ConcretePrototype2(Prototype):
      def clone(self):
          return copy.copy(self)
</code></pre>
  </li>
  <li>
    <p>客户端（<code>client.py</code>）</p>

    <pre><code>  from prototype import *

  p1 = ConcretePrototype1()
  c1 = p1.clone()
</code></pre>
  </li>
</ul>

<h3 id="section-24">适用性</h3>
<p>该模式的优点在于可以从一个对象再创建另外一个可以定制的对象，且不需要知道具体的创建过程。可以实现运行时刻指定实例化类，此外还具有比手动创建所有实例更方便的优点。</p>

<hr />

<h2 id="singleton-">singleton 模式</h2>

<h3 id="section-25">定义</h3>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>

<h3 id="section-26">结构</h3>
<p><img src="http://easypi.github.com/images/DPython/singleton.png" alt="UML图" /></p>

<h3 id="section-27">参与者</h3>
<ul>
  <li>单例类（Singleton）：定义一个get_instance方法，允许客户端访问它的唯一实例。</li>
</ul>

<h3 id="section-28">代码实现</h3>
<ul>
  <li>
    <p>单例类（<code>singleton.py</code>）</p>

    <pre><code>  class Singleton(object):
      instance = None

      def __init__(self):
          pass

      @staticmethod
      def get_instance():
          if Singleton.instance is None:
              Singleton.instance = Singleton()

          return Singleton.instance
</code></pre>
  </li>
  <li>
    <p>客户端（<code>client.py</code>）</p>

    <pre><code>  from singleton import *

  s1 = Singleton.get_instance()
  s2 = Singleton.get_instance()

  if s1 is s2:
      print "in singleton pattern"
</code></pre>
  </li>
</ul>

<h3 id="section-29">适用性</h3>
<p>单例模式保证了类只有一个实例，且可以从一个众所周知的访问点访问它。</p>

<hr />

<h3 id="section-30">源码</h3>
<p>欢迎大家去github上查看<a href="https://github.com/easypi/DPython.git">本项目</a>的所有源文件。</p>

<h3 id="section-31">参考</h3>
<ul>
  <li><a href="http://book.douban.com/subject/1052241/">设计模式-可复用面向对象软件的基础</a> </li>
  <li><a href="http://book.douban.com/subject/2334288/">大话设计模式</a></li>
  <li><a href="http://docs.linuxtone.org/ebooks/Python/Thinking_In_Python.pdf">Thinking in python</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaEE学习之Spring技术]]></title>
    <link href="http://easypi.github.com/blog/2013/02/27/javaee-learning-spring/"/>
    <updated>2013-02-27T17:19:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/02/27/javaee-learning-spring</id>
    <content type="html"><![CDATA[<p>Spring框架是一种从实际开发中抽取出来的框架，提供了一种模板的设计哲学，这些模板完成了大量的通用步骤，开发者只需实现特定应用有关的步骤。Spring提供了一种一站式的解决方案，贯穿表现层，业务层和持久层等，以高度的开放性将已有的框架进行整合。</p>

<!-- more -->

<h2 id="spring">Spring框架使用流程</h2>

<h3 id="webspring">0. 为web应用添加Spring支持</h3>

<p>将Spring项目下的dist路径下的全部jar包和spring-framework-v复制到WEB-INF\lib路径下，即可在web应用中使用Spring框架。</p>

<h3 id="spring-1">1. 编写主程序初始化Spring容器</h3>

<pre><code>package hou;

import PersonService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringTest
{
    public static void main(String[] args)
    {
	    ApplicationContext ctx = new ClassPathXmlApplicationContext("bean.xml");
	    System.out.println(ctx);
	    PersonService p = ctx.getBean("personService" , PersonService.class);
	    p.info();	
    }
}
</code></pre>

<h3 id="springbean">2. 编写被Spring容器管理的bean</h3>

<pre><code>public class PersonService
{
    private String name;

    public void setName(String name)
    {
	    this.name = name;
    }
    public void info()
    {
	    System.out.println("名字"+ name);
    }
}
</code></pre>

<h3 id="beanspring">3. 将bean类部署到Spring容器中，通过配置文件</h3>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.springframework.org/schema/beans"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
    &lt;!-- 将PersonService类部署成Spring容器中的Bean  --&gt;
    &lt;bean id="personService" class="PersonService"&gt;
	    &lt;property name="name" value="wawa"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>通过以上的简单例子，可以发现Spring容器的一个作用，即IoC（控制反转），就是说Spring容器可以创建bean对象，并通过配置文件设置实例的属性值。这是一种通过Spring容器注入设置实例属性值的方法。</p>

<h2 id="spring-2">Spring框架的核心机制</h2>

<p>Spring实现IoC的核心机制是依赖注入。通常当一个调用者的java实例需要另一个被调用者的java实例时，需要调用者来创建被调用者的实例; 而在依赖注入中，创建工作由Spring容器执行，而后注入到调用者中，实现动态管理各个实例。</p>

<h2 id="section">参考</h2>
<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaEE学习之Hibernate技术]]></title>
    <link href="http://easypi.github.com/blog/2013/02/27/javaee-learning-hibernate/"/>
    <updated>2013-02-27T16:05:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/02/27/javaee-learning-hibernate</id>
    <content type="html"><![CDATA[<p>由于目前主流的数据库依然是关系数据库，而Java语言是面向对象的编程语言，二者之间发展的不协调导致二者结合使用时非常麻烦。为了解决这种问题，对象/关系数据库映射（ORM）这种规范完成了面向对象语言与关系数据库之间的映射。当使用了ORM框架以后就可以使用面向对象的方法来操作持久化对象，而ORM框架将这些操作转换为底层的SQL操作。Hibernate就是这样一种ORM工具，由于其开源免费、轻量级封装、可扩展性好等特点成为流行的ORM工具。</p>

<!-- more -->

<h2 id="hibernate">Hibernate框架使用流程</h2>

<h3 id="webhibernate">0. 为web应用添加Hibernate支持</h3>

<p>将下载的hibernate-v.jar和lib路径下的required,bytecode,jpa子目录下的所有jar包添加到应用的类加载路径下，即可使用hibernate。</p>

<h3 id="po">1. 开发PO（持久化对象）</h3>

<p>持久化对象可以实现以面向对象的方式进行数据库操作,hibernate中的持久化对象由普通java类和映射文件两部分构成。一个简单的POJO类如下</p>

<pre><code>public class News {
    private Integer id;
    private String title;
    private String content;

    public Integer getId() {
	    return id;
    }
    public void setId(Integer id) {
	    this.id = id;
    }

    public String getTitle() {
	    return title;
    }
    public void setTitle(String title) {
	    this.title = title;
    }

    public String getContent() {
	    return content;
    }
    public void setContent(String content) {
	    this.content = content;
    }
}
</code></pre>

<p>为了使这个简单的java类具有持久化操作的能力，Hinernate采用映射文件理解持久化类与数据表之间的对应关系，映射文件为xml格式，内容如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
    &lt;class name="News" table="news_table"&gt;
	    &lt;id name="id" type="java.lang.Integer"&gt;
		    &lt;column name="id" /&gt;
		    &lt;generator class="identity" /&gt;
	    &lt;/id&gt;
	    &lt;property name="title" type="java.lang.String"&gt;
		    &lt;column name="title" /&gt;
	    &lt;/property&gt;
	    &lt;property name="content" type="java.lang.String"&gt;
		    &lt;column name="content" /&gt;
	    &lt;/property&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>通过对hibernate-mapping中的class进行配置，即可完成持久化对象的开发。</p>

<h3 id="hibernate-1">2. 编写Hibernate通用配置信息</h3>

<p>对于web应用中连接数据库，以及数据库的配置信息是通用的，通过配置Hibernate的通用信息进行指定要连接的数据库，登录用户名和密码等。该配置通过xml文件完成，内容如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
	    &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
	    &lt;property name="hibernate.connection.password"&gt;32147&lt;/property&gt;
	    &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt;
	    &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;
	    &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;
        &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;
	    &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;	

	    &lt;mapping resource="org/crazyit/app/domain/News.hbm.xml"/&gt;
				       
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>

<h3 id="section">3. 编写操作类代码，使用面向对象的方法操作数据库</h3>

<p>在完成Hibernate的配置后，即可使用面行对象的方法来操作数据库了，在此类的方法中实现对数据库的操作有以下几步。</p>

<ol>
  <li>获取第二步中的通用配置信息</li>
  <li>创建SessionFactory</li>
  <li>创建Session</li>
  <li>开始事务，用面向对象的方法进行处理，最后提交处理</li>
  <li>关闭Session</li>
</ol>

<p>以下代码实现往数据库添加一条信息的功能。</p>

<pre><code>package hou;

import News;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

public class NewsManager {

    public static void main(String[] args)
	    throws Exception {
	    Configuration conf = new Configuration().configure();
	    SessionFactory sf = conf.buildSessionFactory();
	
	    Session sess = sf.openSession();

	    Transaction tx = sess.beginTransaction();

	    News n = new News();

	    n.setTitle("一条信息");
	    n.setContent("信息内容");

	    sess.save(n);
	    tx.commit();
	    sess.close();
	    sf.close();
    }
}
</code></pre>

<h2 id="section-1">参考</h2>
<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JaveEE学习之Struts2技术]]></title>
    <link href="http://easypi.github.com/blog/2013/02/26/javaee-learning-struts/"/>
    <updated>2013-02-26T15:39:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/02/26/javaee-learning-struts</id>
    <content type="html"><![CDATA[<p>Struts2是一款优秀的MVC框架，具有一系列的优点使其具有巨大的吸引力。这些优点包括：允许使用普通java对象作为Action，并且降低了与Servlet API的耦合，更容易测试;支持更多的视图技术;提供良好的可扩展性，更强大的输入校验功能;整合Ajax支持等。本文介绍简单的Struts2应用，来对其进行了解。</p>

<!-- more -->

<h2 id="struts2">Struts2开发应用流程</h2>

<p>这里用一个Struts2开发简单登录处理的web应用来介绍Struts2的开发应用流程</p>

<h3 id="webstruts2">0. 为web应用添加Struts2支持</h3>

<p>将下载的Struts2中lib文件夹下的 <code>commons-fileupload-v.jar, commons-io-v.jar, freemaker-v.jar, javassit-v.jar, ognl-v.jar, struts2-core-v.jar, xwork-core-v.jar</code>等必须的支持文件（其中<code>-v</code>表示版本号，根据下载不同会有所不同）复制到web应用的<code>WEB-INF\lib</code>路径下，如需其他Struts2的支持，复制相应jar文件即可。</p>

<h3 id="webwebxmlstruts2filter">1. 编辑web应用的web.xml配置文件，配置Struts2的核心filter，并使其拦截相关请求。</h3>

<p>在web.xml配置文件中增加以下内容：</p>

<pre><code>&lt;filter&gt;
	&lt;filter-name&gt;struts2&lt;/filter-name&gt;
	&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
	&lt;filter-name&gt;struts2&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<h3 id="jsppostget">2. 编写处理表单请求的JSP页面来发送POST方式请求，如果是GET方式请求，则此步不进行处理。</h3>

<p>在本登录应用中，需要处理表单请求，编写login.jsp如下</p>

<pre><code>&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;
&lt;%@taglib prefix="s" uri="/struts-tags"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt;
&lt;title&gt;&lt;s:text name="loginPage"/&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;s:form action="login"&gt;
    &lt;s:textfield name="username" key="user"/&gt;
    &lt;s:textfield name="password" key="pass"/&gt;
    &lt;s:submit key="login"/&gt;
&lt;/s:form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在本jsp的编写中声明使用了struts2的标签库，并使用该标签库来编写表单请求代码。</p>

<h3 id="action">3. 定义处理用户请求的Action类</h3>

<p>在上述的jsp页面中指定了表单的action为login，因此需要实现一个java类来处理该请求动作。该类通常继承与ActionSupport基类，其代码如下：</p>

<pre><code>import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;

public class LoginAction extends ActionSupport
{
    private String username;
    private String password;

    public String getUsername()
    {
	    return username;
    }
    public void setUsername(String username)
    {
	    this.username = username;
    }

    public String getPassword()
    {
	    return password;
    }
    public void setPassword(String password)
    {
	    this.password = password;
    }

    public String execute() throws Exception
    {
	    if (getUsername().equals("easypi.github.com")
		    &amp;&amp; getPassword().equals("easypi") )
	    {
		    ActionContext.getContext().getSession()
			    .put("user" , getUsername());
	    return SUCCESS;
	    }
	    else
	    {
		    return ERROR;
	    }
    }
}
</code></pre>

<p>该类实现对登录的判断，如果用户名为<code>easypi.github.com</code>，密码为<code>easypi</code>则登录成功，否则失败。</p>

<h3 id="action-1">4. 配置Action以及处理结果和物理视图资源之间的对应关系</h3>

<p>在定义了请求并实现了处理请求action的类之后，需要将请求与action对应起来，用来实现MVC模型。建立struts.xml放置在<code>WEB-INF\classes</code>路径下，使用该文件实现web应用的配置。该文件代码如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="GBK"?&gt;
&lt;!DOCTYPE struts PUBLIC 	"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN"
    "http://struts.apache.org/dtds/struts-2.1.7.dtd"&gt;
&lt;struts&gt;
    &lt;package name="hou" extends="struts-default"&gt;
	    &lt;action name="login" class="LoginAction"&gt;	
		    &lt;result name="input"&gt;/login.jsp&lt;/result&gt;
		    &lt;result name="error"&gt;/error.jsp&lt;/result&gt;
		    &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;
	    &lt;/action&gt;
    &lt;/package&gt;
&lt;/struts&gt;
</code></pre>

<p>其中，将action的login请求使用LoginAction类来进行处理，并可以配置返回结果与物理视图资源之间的对应，如登录成功则进入welcome.jsp页面。</p>

<h3 id="section">5. 实现物理视图资源</h3>

<p>使用Struts2开发的最后一步就是实现需要的视图资源，例如welcome.jsp, error.jsp等页面。至此则完成了使用Struts2开发web应用的全部流程，也实现了一次完整的请求响应流程。</p>

<h2 id="struts2-">Struts2 请求响应流程</h2>

<p>Struts2的开发流程实际是根据请求响应流程而来的，一次请求响应流程如下。</p>

<p><img src="http://ww1.sinaimg.cn/large/a74ecc4cjw1e26usgyzmaj.jpg" alt="Struts2 请求响应流程" /></p>

<p>其中StrutsPrepareAndExecuteFilter称为核心控制器，xxxAction称为业务控制器。通过两级控制器实现解耦，实现xxxAction只处理返回结果，不与物理视图相连，方便代码更改。</p>

<h2 id="section-1">参考</h2>
<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JaveEE学习之Servlet技术]]></title>
    <link href="http://easypi.github.com/blog/2013/01/14/javaEE-learning-servlet/"/>
    <updated>2013-01-14T20:17:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/01/14/javaEE-learning-servlet</id>
    <content type="html"><![CDATA[<p>JSP的本质就是Servlet，编写JSP将其放入web容器中，web容器将JSP编译为Servlet。 由于作为表现层技术使用时，直接使用Servlet的开发效率低下，因此一般使用如JSP等的表现层技术实现。在MVC规范中，Servlet通常被当作控制器使用，虽然还有很多其他MVC的框架可用，但Servlet作为底层实现，对学习JavaEE技术，了解技术原理是有意义的。本文给出一个简单的符合MVC规范的web应用例子，并使用Servlet作为其中的控制器来学习Servlet的相关技术。</p>

<!-- more -->

<h2 id="servlet">Servlet类介绍</h2>

<p>Servlet类是一个继承自<code>HttpServlet</code>的特殊类，可以用来响应用户的请求。在编写自己的Servlet时最常使用的方法是<code>service()</code>方法，该方法处理客户端的请求。因此，一个Servlet类的典型结构为：</p>

<pre><code>//使用@WebServlet Annotation 配置servlet
@WebServlet(name="firstServlet", urlPatterns={"/firstServlet"})
//Servlet类定义
public class FirstServlet extends HttpServlet
{
    public void service(HttpServletRequest request,
    HttpServletResponse response) 
    throws ServletException,java.io.IOException 
    {
        //相应用户请求代码
    }
}
</code></pre>

<h2 id="servlet-1">Servlet类配置</h2>

<p>为了使Servlet响应用户请求，还需将Servlet与Web应用配置起来。配置Servlet有两种方法：在web.xml中配置和使用@WebServlet Annotation配置。使用@WebServlet Annotation直接在Java类的编辑中即可实现，不需web.xml，我认为是更好的方法，因此使用该法进行配置。在使用@WebServlet Annotation时，其常用的几个属性如下：</p>

<ul>
  <li>name:                  指定该Servlet的名称</li>
  <li>urlPatterns/value:     指定该Servlet要处理的url</li>
  <li>initParams：           指定该Servlet的参数</li>
  <li>loadOnStartup:         指定该Servlet是否为load on startup 的Servlet</li>
</ul>

<h2 id="servlet-2">Servlet类作为控制器</h2>

<p>在MVC模式中，Model通常由JavaBean来充当，用来实现业务逻辑、数据访问逻辑等; View通常由JSP来充当，用来收集用户的请求参数、将应用处理的结果和状态等返回呈现给用户等; Controller则由Servlet来充当，实现类似调度员的作用，即用户请求发送到Servlet，Servlet调用Model来处理用户请求，并将结果调用JSP呈现给用户。MVC模式通过对三者作用的分工，实现应用的解耦，方便多人协同开发同一个项目。</p>

<p>现在给出一个简单的MVC模式的应用，实现登录的验证。首先给出<code>login.jsp</code>:</p>

<pre><code>&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
请输入用户名和密码
&lt;!-- 登录表单，被提交至一个Servlet --&gt;
&lt;form id="login" method="post" action="login"&gt;
用户名： &lt;input type="text" name="username"/&gt; &lt;br/&gt;
密码：  &lt;input type="password" name="pass" /&gt; &lt;br/&gt;
&lt;input type="submit" value="登录" /&gt; &lt;br/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>然后给出控制器Servlet类<code>LoginServlet.java</code>:</p>

<pre><code>import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.annotation.*;

import java.sql.*;
import java.io.*;

@WebServlet(name="login", urlPatterns={"/login"})

public class LoginServlet extends HttpServlet {

    public void service(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, java.io.IOException 
    {
            String errMsg="";
            //Servlet不输出响应到客户端，因此必须将请求转发
            RequestDispatcher rd;

            //获取请求参数    
            String username =  request.getParameter("username");
            String pass = request.getParameter("pass");
            PrintStream out = new PrintStream(response.getOutputStream());
            //out.println("name" + username);

            try {
                //Servlet 本身不处理业务逻辑，调用JavaBean处理用户请求
                DbDao dd = new DbDao("com.mysql.jdbc.Driver",
                    "jdbc:mysql://localhost:3306/javaee","root","mysql");
                //查询结果集
                ResultSet rs = dd.query("select pass from user_table"
                    + "where name = ?", username);
                if (rs.next()) {
            
                    //用户名和密码匹配
                    if (rs.getString("pass").equals(pass)) {
                        // 获取session对象
                        HttpSession session = request.getSession(true);
                        //设置session属性，跟踪用户会话状态
                        session.setAttribute("name", username);
                        //获取转发对象
                        rd = request.getRequestDispatcher("/welcome.jsp");
                        rd.forward(request, response);
                    }
                    else {
                        //用户名密码不匹配
                        errMsg += "您的用户名密码不符合，请重试";
                    }
                }
                else {
                    //用户名不存在时
                    errMsg += "您的用户名不存在，请先注册";
                }
            
            }
            catch (Exception e) {
                out.println(errMsg);
                e.printStackTrace();
            }

            //如果出错，转发到重新登录
            if (errMsg != null &amp;&amp; !errMsg.equals("")) {
                rd = request.getRequestDispatcher("/login.jsp");
                request.setAttribute("err", errMsg);
                rd.forward(request, response);
            }

        }   
}
</code></pre>

<p>最后给出Model类<code>DbDao.java</code>：</p>

<pre><code>import java.sql.*;

public class DbDao {
    private Connection conn;
    private String driver;
    private String url;
    private String username;
    private String pass;

    public DbDao() {}
    public DbDao(String driver, String url, String username, String pass) {
        this.driver = driver;
        this.url = url;
        this.username = username;
        this.pass = pass;
    }
    //各属性的setter和getter方法
    public void setDriver(String driver) {
        this.driver = driver;
    }
    public void setUrl(String url) {
        this.url = url;
    }
    public void setUsername(String username) {
        this.username=username;
    }
    public void setPass(String pass) {
        this.pass = pass;
    }
    public String getDriver() {
        return this.driver;
    }
    public String getUrl() {
        return this.url;
    }
    public String getUsername() {
        return this.username;
    }
    public String getPass() {
        return this.pass;
    }

    //获取数据库连接
    public Connection getConnection() throws Exception{
        if (conn == null) {
            Class.forName(this.driver);
            conn = DriverManager.getConnection(url, username, this.pass);
        }
        return conn;
    }
    // 插入记录
    public boolean insert(String sql, Object... args) throws Exception {
        PreparedStatement pstmt = getConnection().prepareStatement(sql);
        for (int i=0; i&lt;args.length; i++) {
            pstmt.setObject(i+1, args[i]);
        }
        if (pstmt.executeUpdate() != 1) {
            return false;
        }
        return true;
    }
    // 执行查询
    public ResultSet query(String sql, Object... args) throws Exception {
        PreparedStatement pstmt = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; args.length; i++) {
            pstmt.setObject(i+1, args[i]);
        }
        return pstmt.executeQuery();
    }
    //执行修改
    public void moify (String sql, Object... args) throws Exception {
        PreparedStatement pstmt = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; args.length; i++) {
            pstmt.setObject(i+1, args[i]);
        }
        pstmt.executeUpdate();
        pstmt.close();
    }
    //关闭数据库连接的方法
    public void closeConn() throws Exception {
        if (conn != null &amp;&amp; !conn.isClosed()) {
            conn.close();
        }
    }
}
</code></pre>

<p>至此，一个完整的MVC模式的web应用就完成了，其中JSP充当View，用来提供用户交流界面; Servlet充当控制器, 起调动作用；JavaBean充当模型，处理业务逻辑和数据逻辑。 </p>

<h2 id="servlet-3">Servlet类相关</h2>

<h3 id="filter">Filter</h3>

<p>Filter可以看作Servlet的加强版，它是一个处理链，典型的使用流程是：使用Filter对用户请求进行预处理，然后将请求交给Servlet进行处理，最后对服务器响应进行后处理。Filter的作用主要有以下几个方面：</p>

<ul>
  <li>拦截HttpServletRequest进行预处理，可以修改请求数据，然后交给Servlet处理</li>
  <li>拦截HttpServletResponse进行后处理，可以修改Servlet的处理结果，然后作为服务器的响应结果。</li>
</ul>

<p>Filter的使用和Servlet非常类似，包括定义Filter类和配置Filter两步。其中Filter类必须实现<code>javax.servlet.Filter</code>接口，主要功能在<code>doFilter()</code>函数内实现。Filter的配置也可使用@webFilter Annotation进行配置。</p>

<h3 id="listener">Listener</h3>

<p>Listener完成对web应用内事件的监听和处理，从而允许当web应用内有事件发生时，可以回调事件监听器内的方法。Listener的使用与Servlet类似，分为定义Listener实现类和配置Listener两步。自定义的Listener类根据不同的web应用时间需实现不同的接口，常见的web监听器接口有以下几个：</p>

<ul>
  <li>ServletContextListener: 用于监听web应用的启动和关闭</li>
  <li>ServletContextAttributerListener: 用于监听ServletContext范围（application）内属性的更改</li>
  <li>ServletRequestListener： 用于监听用户请求</li>
  <li>ServletRequestAttributerListener: 用于监听ServletRequest范围（request）内属性的更改</li>
  <li>ServletSessionListener： 用于监听用户Session的开始和结束</li>
  <li>ServletSessionAttributerListener: 用于监听ServletSession范围（session）内属性的更改</li>
</ul>

<h2 id="section">参考</h2>
<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaEE学习之JSP技术]]></title>
    <link href="http://easypi.github.com/blog/2013/01/11/javaEE-learning-JSP/"/>
    <updated>2013-01-11T17:35:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/01/11/javaEE-learning-JSP</id>
    <content type="html"><![CDATA[<p>JSP(Java Server Page)与Servlet是JavaEE的基本成员，基本形式为在HTMl文件中添加Java代码，辅以使用JSP标签，在静态的HTML的基础上有了动态提供页面内容的能力，使从事java开发的人员可以将java知识运用到动态网页开发的应用中。</p>

<p>本文是JavaEE学习笔记的第一篇，以一个简单的使用JSP的web应用来开始JaveEE技术的学习，并且说明JSP与Servlet类之间的联系和工作原理，最后还总结了一些包括脚本语法、编译和动作指令、内置Servlet对象、和自定义标签等一些具体的JSP的技术。</p>

<!-- more -->

<h2 id="hello-jsp">Hello JSP！</h2>

<p>首先看一个简单的基于JSP的动态网页应用，在Eclipse中新建一个Dynamic Web Project，在WebContent文件夹下新建一JSP文件：Hello.jsp</p>

<pre><code>&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt; 欢迎&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
欢迎学习javaEE知识，现在时间是&lt;br/&gt;
&lt;%out.println(new java.util.Date()); %&gt; &lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>其中第一行用<code>&lt;%@ %&gt;</code>包起来的内容为JSP的编译指令，用来定义说明JSP文件的一些基本信息。该行之下就是一个普通的HTML文件，只是其中有一行用<code>&lt;% %&gt;</code>包起来，这表明其中的内容为java代码，该行用来输出当前的时间。将该工程部署到tomcat服务器上访问该JSP文件能够得到期望输出。由此可知，JSP技术可以概括为两者的结合：一为HTML技术，用来实现网页静态内容的显示; 二为java技术，用来实现动态内容的处理。JSP技术通过将两者结合在一起实现了动态网页的设计。在表面上，作为表现层技术，按照其语法约定编写JSP程序即可实现设计的需要; 本质上，JSP依靠Servlet实现。</p>

<h2 id="jsp-">JSP 的实现原理</h2>

<p>JSP的本质是Servlet，当用户向指定Servlet发送请求时，Servlet利用动态输出流动态生成HTML页面，包括每一个静态的HTML标签和所有在HTML页面中出现的内容。</p>

<p>为了表明JSP的运行原理，来看一个复杂一点的例子：</p>

<pre><code>&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt; 欢迎&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
欢迎学习javaEE知识，现在时间是&lt;br/&gt;
&lt;%out.println(new java.util.Date()); %&gt;
&lt;br/&gt;
&lt;!-- 在JSP中加入java代码，实现动态 --&gt;
&lt;%
for (int i = 0; i &lt; 5; i++) {
    out.println("&lt;font size='"+i+"'&gt;");
%&gt;
测试字体大小 &lt;/font&gt; &lt;br/&gt;
&lt;% }%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在刚才的hello.jsp文件中加入了一个for循环结构来控制输出字体的大小。为了更加清楚的了解JSP的实现原理，需要分析该JSP文件编译而成的Servlet文件，该文件可以在tomcat的work文件夹中找到（如果使用eclipse并将tomcat的项目部署在workspace的.metadata文件夹下，则work不在tomcat目录下，而在.metadata文件夹下）。找到的对应的Hello_jsp.java文件如下</p>

<pre><code>package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class Hello_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants;

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() {
    return _jspx_dependants;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html; charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
                null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\n");
      out.write("&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n");
      out.write("&lt;html&gt;\n");
      out.write("&lt;head&gt;\n");
      out.write("&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;\n");
      out.write("&lt;title&gt; 欢迎&lt;/title&gt;\n");
      out.write("&lt;/head&gt;\n");
      out.write("&lt;body&gt;\n");
      out.write("欢迎学习javaEE知识，现在时间是&lt;br/&gt;\n");
out.println(new java.util.Date()); 
      out.write("\n");
      out.write("&lt;br/&gt;\n");
      out.write("\n");
      out.write("&lt;!-- 在JSP中加入java代码，实现动态 --&gt;\n");

for (int i = 0; i &lt; 5; i++) {
    out.println("&lt;font size='"+i+"'&gt;");

      out.write("\n");
      out.write("测试字体大小 &lt;/font&gt; &lt;br/&gt;\n");
 }
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("&lt;/body&gt;\n");
      out.write("&lt;/html&gt;");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null &amp;&amp; out.getBufferSize() != 0)
          try { out.clearBuffer(); } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
</code></pre>

<p>由此java代码可以看出，JSP代码被编译转化成了一个继承自HttpJspBase的类，该类有三个方法<code>_jspInit(), _jspDestroy(), _jspService()</code>,分别实现初始化JSP/Servlet、销毁JSP/Servlet、和响应用户请求。在<code>_jspService()</code>中可以找到对应于上述JSP代码的实现：对于静态的HTML代码，调用<code>out.write()</code>方法直接输出; 对于java代码，则直接以原始形式存在与该方法内，用来动态实现要求。</p>

<p>通过该例可知，JSP被编译成了一个Servlet的类来实现设计要求，本质上还是Servlet，实际上还是运行了Servlet类的方法，因此编写JSP或者直接编写Servlet代码本质上是一样的。但是由于直接编写Servlet代码比较麻烦，开发实现慢，相比而言开发JSP代码则方便很多,能够大大提高动态网站的开发效率。需要注意的是，JSP代码向Servlet代码转化过程中由于存在编译转化的过程，因此每个JSP页面的第一次访问会比较慢。</p>

<h2 id="jsp">JSP的具体技术</h2>

<h3 id="jsp-1">JSP注释语法</h3>
<p>JSP的注释语法为：</p>

<pre><code>&lt;%-- JSP注释内容 --%&gt; 
</code></pre>

<h3 id="jsp-2">JSP声明</h3>
<p>在JSP文件中的声明内容将会被转换为相应Servlet的成员变量和成员方法，符合java语法。JSP的声明语法为</p>

<pre><code>&lt;%! 声明内容 %&gt;
</code></pre>

<h3 id="jsp-3">JSP输出表达式</h3>
<p>使用JSP的输出表达式可以代替<code>out.println()</code>语句，注意<em>输出表达式语法内不能有分号</em>。其语法为：</p>

<pre><code>&lt;%= 输出内容 %&gt;
</code></pre>

<h3 id="jsp-4">JSP脚本</h3>
<p>使用JSP脚本语法可以方便的将java代码嵌入到HTML中，实现动态功能。其语法为：</p>

<pre><code>&lt;% 脚本内容 %&gt;
</code></pre>

<h3 id="jsp-5">JSP编译指令</h3>
<p>JSP编译指令是通知JSP引擎的信息，不直接产生输出且都有默认值，因此无需为每个指令赋值。其语法为：</p>

<pre><code>&lt;%@ 指令名 属性名="属性值"%&gt;
</code></pre>

<p>常见的编译指令有<code>page，include，taglib</code>三个：</p>

<ul>
  <li>page: 通常位于JSP顶端，有<code>language, extends, import, session, buffer, autoFlush, info, errorPage, isErrorPage, contentType, pageEncoding</code>等属性，用来说明语言、继承父类、导入包等。</li>
  <li>include: 实现静态导入外部文件的功能，能将外部文件嵌入到该文件并且解析其JSP语句。该导入会将目标页面的其他编译指令导入，如果与本页编译指令冲突则会报错。还可以通过JSP的动作指令<code>&lt;jsp:include&gt;</code>实现动态导入，不会导入目标页面的其他编译指令。</li>
  <li>taglib: 用于访问和定义自己的标签库。</li>
</ul>

<h3 id="jsp-6">JSP动作指令</h3>
<p>JSP动作指令是运行时的动作，是JSP脚本的标准化写法。其语法为：</p>

<pre><code>&lt;指令名  属性名="属性值" /&gt;
</code></pre>

<p>常用的动作指令有：</p>

<ul>
  <li>jsp:forward: 用于将页面响应转发到另外的界面</li>
  <li>jsp:param: 用于传递参数，需与其他支持参数的标签一起使用</li>
  <li>jsp:include: 用于动态引入另一个JSP页面</li>
  <li>jsp:plugin: 用于下载javaBean或Applet到客户端执行</li>
  <li>jsp:useBean: 创建一个javaBean实例</li>
  <li>jsp:setProperty: 设置javaBean实例的属性</li>
  <li>jsp:getProperty: 获得javaBean实例的属性</li>
</ul>

<h3 id="jsp-7">JSP脚本的内置对象</h3>
<p>JSP脚本中有9个内置对象，是Servlet API接口的实例，可以直接使用。</p>

<ul>
  <li>application： java.servlet.ServletContext的实例，代表JSP所属web应用本身。</li>
  <li>config：java.servlet.ServletConfig的实例，代表该JSP的配置信息。</li>
  <li>exception: java.lang.Throwable的实例，该实例代表其它页面的异常和错误，只对errorPage才可使用。</li>
  <li>out： javax.servlet.jsp.JspWriter的实例，代表JSP页面的输出流，用于形成HTML页面</li>
  <li>page: java.lang.Object的实例，代表该页面本身，就是该Servlet的this。</li>
  <li>pageContext: javax.servlet.jsp.PageContext的实例，代表该JSP页面上下文，可用此访问页面中的共享数据。</li>
  <li>request: javax.servlet.http.HttpServletRequest的实例，代表客户端的一次请求，所有请求参数都在此对象中。</li>
  <li>response: javax.servlet.http.HttpServletResponse的实例，代表服务器对客户端的响应，常用与重定向。</li>
  <li>session: javax.servlet.http.HttpSession的实例，代表一次会话。</li>
</ul>

<p>有上述的java代码可以看出，其中request和response是<code>_jspService()</code>的形参，而其他对象都在该方法内创建，为该方法的局部变量，因此在JSP脚本中可直接使用，不需再次声明。<code>_jspService()</code>方法用来完成解析客户端请求数据、处理客户请求、和生成响应数据的工作。但是由于JSP和Servlet等通常有web服务器进行调用，二者之间并不互相调用，为了实现二者之间的数据交换，web服务器定义了四个类似map的结构充当中介的角色，实现二者之间的数据交换。这四个结构根据范围由大到小依次是<code>application &gt; session &gt; request &gt; page</code>：</p>

<ul>
  <li>application: 对整个web应用有效，其中的数据可被该应用下的JSP和Servlet访问。</li>
  <li>session: 对一次会话有效，其中的数据可被该次会话中是JSP和Servlet访问</li>
  <li>request: 对一次请求有效，其中的数据可被该次请求中是JSP和Servlet访问</li>
  <li>page: 只对当前页面有效，其中的数据可以被该JSP页面的脚本，声明中访问。</li>
</ul>

<p>对于客户端发送的请求，其请求参数有GET和POST两种方式。二者之间存在一些差异：</p>

<ul>
  <li>GET: 两种情况下使用该类方式请求，一是直接在浏览器地址栏输入访问地址时，二是提交表单时form元素的method属性为设置或设为get时。该类请求参数的名和值会被转换为字符串附加于地址之后，用户可以看到，且传送数据量较小。</li>
  <li>POST: 提交表单的form元素的method属性设为post时使用该类方式请求。在地址栏看不到请求参数值，传送数量较大。    </li>
</ul>

<p>对于请求的传递，会用到转发（forward）和重定向（redirect）两种方式。二者的差异为：</p>

<ul>
  <li>执行forward仍然为该次请求，而redirect则生成第二次请求。</li>
  <li>由于是同一次请求，forward的请求参数保留且不变; redirect则不同，生成的新的请求不会保留上次请求的参数。</li>
  <li>forward处理浏览器的地址栏不会变化，redirect则会改为重定向的目标URL，与在地址栏输入新URL回车效果相同。</li>
</ul>

<h3 id="jsp-8">JSP的自定义标签</h3>
<p>通过使用JSP的自定义标签库规范，可以扩展JSP的标签，将复杂的功能封装在简单的标签内，提高开发效率。使用该技术主要分三步：</p>

<ul>
  <li>开发自定义标签处理类: 该类继承自javax.servlet.jsp.tagext.SimpleTagSupport, 通过重写doTag()方法实现功能。</li>
  <li>建立TLD（Tag Library Definition）文件实现标签名与标签处理类的关联。</li>
  <li>在JSP文件中，通过编译指令指明使用的标签库，即可在JSP中使用自定义的标签。</li>
</ul>

<h2 id="section">参考</h2>
<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress在github pages上搭建个人博客]]></title>
    <link href="http://easypi.github.com/blog/2013/01/05/using-octopress-to-setup-blog-on-github/"/>
    <updated>2013-01-05T22:19:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/01/05/using-octopress-to-setup-blog-on-github</id>
    <content type="html"><![CDATA[<p>github不仅能够提供代码托管和版本控制系统，现在又有了github pages功能，可以让你将个人的博客搭建在此，通过git 工具方便的发布个人博客。由于pages只提供了管理和呈现静态网页的功能，而静态网页的生成则需自己实现。Jekyll工具可用来实现静态网页的生成，但是使用起来相对麻烦，需要对Html,CSS和javascript比较熟悉。作为希望更加关注内容的博客用户来说，Octopress给出了一个更好的选择，Octopress是一个基于Jekyll的博客生成框架，它处理了Jekyll那些麻烦的配置，安装后只需几条简单的命令就可以发布你的博客了。</p>

<p>本文就是基于该系统发布的第一篇，本文记录了在ubuntu 12.04系统下搭建该博客系统的过程，同时也加入了一些自己的配置，比如增加新浪微波侧边栏、去除分享到twitter等国内不能使用的功能、增加分享到微博等网站的功能、添加评论系统等。现在做一总结，分享给大家。</p>

<!--more-->

<h2 id="section">安装</h2>

<p>Octopress的安装还是很方便的,按照其官方文档<a href="http://octopress.org/docs/setup">http://octopress.org/docs/setup</a>就能安装成功,在此只是翻译和简单罗列一下。</p>

<h3 id="ruby">安装Ruby</h3>

<p>大家现在应该已经有了git系统，关于git本文不多做介绍，默认大家已经会用git系统了。</p>

<p>首先安装Octopress依赖的的Ruby, Octopress 2.0依赖的是Ruby 1.9.3版本，可以在终端中输入<code>ruby --version</code>查看版本信息。Ubuntu系统中可以使用apt-get 安装，但是注意默认安装的Ruby版本可能不对，因此安装时需指明版本：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo apt-get install ruby1.9.3</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在终端中输入<code>ruby --version</code>查看版本信息应该是正确了。如果之前安装过Ruby但是版本不符合的，则需要使用rbenv或RVM来进行安装，具体可查看<a href="http://octopress.org/docs/setup/rbenv/">http://octopress.org/docs/setup/rbenv/</a> 或 <a href="http://octopress.org/docs/setup/rvm/">http://octopress.org/docs/setup/rvm/</a>.</p>

<h3 id="octopress">安装Octopress</h3>

<p>首先将Octopress工具clone到本地一文件夹：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git clone git://github.com/imathis/octopress.git octopress
</span><span class="line">cd octopress</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后安装其它依赖</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gem install bundler
</span><span class="line">rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command
</span><span class="line">bundle install</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后安装默认Octopress主题</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake install</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>至此Octopress安装完成。</p>

<h2 id="github-pages">配置github pages</h2>

<p>github pages 可以提供一个域名为<code>http://username.github.com</code>的博客，首先需要在github新建一个名为<code>username.github.com</code>的代码仓库，然后就可以使用Octopress博客部署到该域名上了。(该username必须与你在github上的用户名一致)</p>

<p>在代码仓库建立完成后，可以使用Octopress提供的脚本完成后面的部署工作：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake setup_github_pages</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在此过程会询问你的代码仓库的地址，按提示完成即可。此过程可能需要提供SSH key,如果没有可以参照<a href="https://help.github.com/articles/generating-ssh-keys">https://help.github.com/articles/generating-ssh-keys</a>设置。</p>

<p>然后就可以将默认的博客发布到你自己的域名了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake generate
</span><span class="line">rake deploy</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>几分钟后，你的域名上应该已经有了默认的博客了，至此安装和配置github pages就完成了。你还可以将Octopress目录加入到github中进行管理：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git add .
</span><span class="line">git commit -m 'your message'
</span><span class="line">git push origin source</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="octopress-1">配置Octopress</h2>

<p>Octopress的配置主要在<code>_config.yml</code>文件中，可以配置博客的主副标题，作者名，邮箱等，配置十分方便。在此建议将国内不能使用的功能，如twitter,google+等相关项设为false或直接删除，随后将介绍如何使用新浪微博等代替。</p>

<h2 id="section-1">开始写文章</h2>

<p>使用Octopress书写和发布文章只需几条命令即可。首先运行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake new_post["title"]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>该命令将会在<code>source/_posts</code>目录下生成一个名为<code>YYYY-MM-DD-post-title.markdown</code>的文件，编辑该文件即可书写你的文章了。文章书写使用markdown语法，<a href="http://wowubuntu.com/markdown/index.html">http://wowubuntu.com/markdown/index.html</a>给出了markdown语法的介绍，该语法简单方便。</p>

<p>在文章书写完成后，就可以生成静态网页了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake generate</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果想要在发布到github上之前在本机进行预览，执行下面的命令，然后访问<a href="http://localhost:4000">http://localhost:4000</a> 就可以看到完成的状态了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake preview</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后可以发布到github上了，</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake deploy</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>至此，你已经可以在自己的博客上写文章了。<a href="http://octopress.org/docs/blogging/plugins/">http://octopress.org/docs/blogging/plugins/</a>这里给出了常用的书写文章时可以添加代码、图片、视频等内容的语法，用此可以生成图文并茂的文章。</p>

<h2 id="section-2">高级配置</h2>
<p>在此部分主要介绍在侧边增加新浪微博秀，在文章底部增加分享到和评论的功能。</p>

<h3 id="section-3">新浪微博秀</h3>

<ul>
  <li>在<code>_config.yml</code>文件中将<code>default_asides</code>处代码改为如下，即去除不要的侧边栏，并加入微博侧边栏。</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">default_asides: [asides/recent_posts.html, asides/github.html, custom/asides/weibo.html]</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>到<a href="http://app.weibo.com/tool/weiboshow">http://app.weibo.com/tool/weiboshow</a>获取自己微博秀的代码。</li>
  <li>在<code>source/_includes/custom/asides</code>文件夹下新建weibo.html文件并编辑如下,将获取的微博秀代码插入到相应位置：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;section&gt;
</span><span class="line">    &lt;h1&gt;新浪微博&lt;/h1&gt;
</span><span class="line">    &lt;ul id="weibo"&gt;
</span><span class="line">    &lt;li&gt;
</span><span class="line">
</span><span class="line">    &lt;!-- 在此插入获得的微博秀代码 --&gt;
</span><span class="line">
</span><span class="line">      &lt;/li&gt;
</span><span class="line">    &lt;/ul&gt;
</span><span class="line">&lt;/section&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>至此你的侧边就有了你自己的微博秀了。</p>

<h3 id="section-4">分享到和评论功能</h3>

<ul>
  <li>在<code>_config.yml</code>文件中增加一项，可用此来控制是否开启分享到和评论功能，设为<code>false</code>则可关闭：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># Sina Weibo
</span><span class="line">weibo_sharing: true</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>编辑<code>/source/_includes/post/sharing.html</code>,增加如下代码：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//下面的大括号与百分号间无空格，如果复制，请去掉  
</span><span class="line">{ % if site.weibo_sharing % }
</span><span class="line">{ % include custom/weibo_sharing.html % }
</span><span class="line">{ % endif % }</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>在<code>source/_includes/custom</code>下新建<code>weibo_sharing.html</code>文件。</li>
  <li>到<a href="http://www.bshare.cn/">http://www.bshare.cn/</a>获取喜欢按钮样式的分享代码，加入到<code>weibo_sharing.html</code>中，即可增加分享到按钮功能。</li>
  <li>到<a href="http://www.uyan.cc/">http://www.uyan.cc/</a>获取评论功能的代码，加入到<code>weibo_sharing.html</code>中，即可增加评论功能。</li>
</ul>

<h2 id="section-5">参考</h2>
<ul>
  <li><a href="http://octopress.org/docs/">http://octopress.org/docs/</a></li>
  <li><a href="https://help.github.com/categories/20/articles">https://help.github.com/categories/20/articles</a></li>
  <li><a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
