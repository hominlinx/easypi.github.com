<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DesignPattern | easypi's blog]]></title>
  <link href="http://easypi.github.com/blog/categories/designpattern/atom.xml" rel="self"/>
  <link href="http://easypi.github.com/"/>
  <updated>2013-03-29T18:07:59+08:00</updated>
  <id>http://easypi.github.com/</id>
  <author>
    <name><![CDATA[厚之成]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：Python语言实现之结构型模式]]></title>
    <link href="http://easypi.github.com/blog/2013/03/29/design-pattern-in-python-structual-ones/"/>
    <updated>2013-03-29T18:02:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/03/29/design-pattern-in-python-structual-ones</id>
    <content type="html"><![CDATA[<p>结构型模式涉及到如何组合类和对象以获得更大的结构。本文将给出结构型模式的定义，结构，代码实现和特点等内容。本文涉及的结构型模式包括：adapter模式，bridge模式，composite模式，decorator模式，facade模式，flyweight模式，和proxy模式。</p>

<!--more-->


<h2>Adapter（适配器）模式</h2>

<h3>定义</h3>

<p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>

<h3>结构</h3>

<p><img src="/images/DPython/adapter.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>Target: 客户所期待的与特定领域相关的接口。</li>
<li>Adaptee: 需要适配的类，是一个已存在的接口。</li>
<li>Adapter：对Adaptee的接口与Target接口进行适配。</li>
<li>Client：客户端，与复合Target接口的对象协同。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>Target类（<code>target.py</code>）</p>

<pre><code>  class Target(object):
      def request(self):
          print "nomal request"
</code></pre></li>
<li><p>Adaptee类（<code>adaptee.py</code>）</p>

<pre><code>  class Adaptee(object):
      def specific_request(self):
          print "specific request"
</code></pre></li>
<li><p>Adapter类（<code>adapter.py</code>）</p>

<pre><code>  from target import *
  from adaptee import *

  class Adapter(Target):
      def __init__(self):
          self.myadaptee = Adaptee()

      def request(self):
          self.myadaptee.specific_request()
</code></pre></li>
<li><p>客户端（<code>client.py</code>）</p>

<pre><code>  from adapter import *

  target = Adapter()
  target.request()
</code></pre></li>
</ul>


<h3>适用性</h3>

<ul>
<li>想使用一个已经存在的类，而他的接口不符合你的要求时可以使用此模式。</li>
<li>客户端代码可以统一调用同一接口，即使是对不相关或不可预见的类。</li>
</ul>


<hr />

<h2>Bridge（桥接）模式</h2>

<h3>定义</h3>

<p>将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p>

<h3>结构</h3>

<p><img src="/images/DPython/bridge.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>Abstraction: 定义抽象类的接口，维护一个指向Implementor类对象的指针。</li>
<li>RefinedAbstraction：扩充Abstraction定义的接口。</li>
<li>Implementor: 定义实现类的接口，该接口不一定要与Abstraction的接口一致，该类接口提供基本操作，Abstraction类定义了基于这些基本操作的较高层次的操作。</li>
<li>ConcreteImplementor：具体实现Implementor的接口。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>Implementor 类（<code>Implementor.py</code>）</p>

<pre><code>  class Implementor(object):
      def operation_imp(self):
          pass

  class ConcreteImplementorA(Implementor):
      def operation_imp(self):
          print "ConcreteImplementorA operate"

  class ConcreteImplementorB(Implementor):
      def operation_imp(self):
          print "ConcreteImplementorB operate"
</code></pre></li>
<li><p>Abstraction 类（<code>abstraction.py</code>）</p>

<pre><code>  from implementor import *

  class Abstraction(object):
      def __init__(self):
          self.imp = Implementor()

      def set_imp(self,conc_imple):
          self.imp = conc_imple;

      def operate(self):
          self.imp.operation_imp()
</code></pre></li>
<li><p>client （<code>client.py</code> ）</p>

<pre><code>  from abstraction import *
  from implementor import *

  ab = Abstraction()
  imp = ConcreteImplementorA()
  ab.set_imp(imp)
  ab.operate()
</code></pre></li>
</ul>


<h3>适用性</h3>

<ul>
<li>不希望抽象与实现部分有一个固定的绑定，该模式可以在运行时刻配置抽象类的实现。</li>
<li>希望抽象部分和实现部分都可通过子类进行扩充。该模式可以独立的对抽象与实现分别扩充。</li>
<li>希望实现系统的多角度分类，减少各分类之间的耦合。</li>
</ul>


<hr />

<h2>Composite（组合）模式</h2>

<h3>定义</h3>

<p>将对象组合成树形结构以表示“部分-整体”的层次结构。该模式使得用户对单个对象和组合对象的使用具有一致性。</p>

<h3>结构</h3>

<p><img src="/images/DPython/composite.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>Component：为组合中的对象声明接口，在适当情况下实现所有类公有接口的缺省行为，声明一个用于管理Component的子组件</li>
<li>Leaf：在组合中表示叶节点对象，叶节点没有子节点。</li>
<li>Composite：定义有子部件的那些部件的行为，存储子部件，实现接口中与子部件有关的操作</li>
<li>Client：通过Component接口操作组合部件对象。</li>
<li>协作： 用户使用Component接口与组合结构中的对象进行交互，如果接受者是一个叶节点，则直接处理请求，如果接受者是Composite，它通常将请求发送给它的子部件，并执行一些辅助动作。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>(<code>composite.py</code>）</p>

<pre><code>  class Component(object):
      def operation(self,depth):
          pass

      def add(self, component):
          pass

      def remove(self, component):
          pass

  # Leaf
  class Leaf(Component):
      def operation(self, depth):
          print "-"*depth + "leaf"

  # Composite
  class Composite(Component):
      def __init__(self):
          self.children = []

      def operation(self, depth):
          print "-"*depth + "composite"
          for c in self.children:
              c.operation(depth+2)

      def add(self, component):
          self.children.append(component)

      def remove(self, component):
          self.children.remove(component)
</code></pre></li>
<li><p>Client（<code>client.py</code>）</p>

<pre><code>  from composite import *

  comp1 = Composite()
  comp1.add(Leaf())
  comp1.add(Leaf())

  root = Composite()
  leaf = Leaf()
  root.add(leaf)
  root.add(comp1)

  root.operation(2)

  root.remove(leaf)
  root.operation(2)
</code></pre></li>
</ul>


<h3>适用性</h3>

<ul>
<li>希望表达对象的部分-整体层次结构，且希望用户忽略组合对象与单个对象的不同并统一的使用组合结构中的所有对象时。</li>
<li>使设计更加一般化，并且容易增加新的组件，客户端不需根据新组间而改变。</li>
</ul>


<hr />

<h2>Decorator（装饰）模式</h2>

<h3>定义</h3>

<p>该模式也叫Wrapper（包装器），动态的给一个对象添加一些额外的职责。就增加功能来说，该模式比生成子类更为灵活。</p>

<h3>结构</h3>

<p><img src="/images/DPython/decorator.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>Component：定义一个对象接口，可以给这些对象动态的添加职责。</li>
<li>ConcreteComponent：定义一个对象，可以给这个对象添加一些职责。</li>
<li>Decorator：维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。</li>
<li>ConcreteDecorator：具体的装饰对象，向组件添加职责。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>Component类（<code>component.py</code>）</p>

<pre><code>  class Component(object):
      def operation(self):
          pass

  class ConcreteComponent(Component):
      def operation(self):
          print "concrete component operate"
</code></pre></li>
<li><p>Decorator类（<code>decorator.py</code>）</p>

<pre><code>  from component import *

  class Decorator(Component):
      def __init__(self):
          self.comp = Component()

      def set_component(self, component):
          self.comp = component

      def operation(self):
          self.comp.operation()

  class ConcreteDecoratorA(Decorator):
      def __init__(self):
          super(ConcreteDecoratorA, self).__init__()
          self.added_state = " "

      def operation(self):
          super(ConcreteDecoratorA, self).operation()
          self.added_state += "new state"
          print self.added_state

  class ConcreteDecoratorB(Decorator):
      def __init__(self):
          super(ConcreteDecoratorB, self).__init__()

      def operation(self):
          super(ConcreteDecoratorB, self).operation()

      def added_behavior(self):
          print "added behavior"      
</code></pre></li>
<li><p>客户端（<code>client.py</code>）</p>

<pre><code>  from decorator import *

  c = ConcreteComponent()
  d1 = ConcreteDecoratorA()
  d2 = ConcreteDecoratorB()

  d1.set_component(c)
  d2.set_component(d1)

  d2.operation()
</code></pre></li>
</ul>


<h3>适用性</h3>

<ul>
<li>希望不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责，比静态继承更灵活。</li>
<li>把类的核心职责和装饰功能区分开来，去除类中重复的装饰逻辑。</li>
</ul>


<hr />

<h2>Facade（外观）模式</h2>

<h3>定义</h3>

<p>为子系统中的一组接口提供一个一致的界面，该模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>

<h3>结构</h3>

<p><img src="/images/DPython/facade.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>Facade：知道哪些子系统负责处理请求，将客户的请求代理给合适的子系统对象。</li>
<li>SubSystem：实现子系统的功能，处理Facade对象指派的任务，无需Facade对象的任何信息。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>SubSystem类（<code>subsystem.py</code>）</p>

<pre><code>  class SubSystem1(object):
      def method1(self):
          print "sub system 1 method 1"

  class SubSystem2(object):
      def method2(self):
          print "sub system 2 method 2"

  class SubSystem3(object):
      def method3(self):
          print "sub system 3 method 3"
</code></pre></li>
<li><p>Facade类（<code>facade.py</code>）</p>

<pre><code>  from subsystem import *

  class Facade(object):
      def __init__(self):
          self.sub1 = SubSystem1()
          self.sub2 = SubSystem2()
          self.sub3 = SubSystem3()

      def method_a(self):
          self.sub1.method1()
          self.sub3.method3()
          self.sub2.method2()

      def method_b(self):
          self.sub3.method3()
          self.sub2.method2()
          self.sub1.method1()
</code></pre></li>
<li><p>client（<code>client.py</code>）</p>

<pre><code>  from facade import *

  fc = Facade()
  fc.method_a()
  fc.method_b()
</code></pre></li>
</ul>


<h3>适用性</h3>

<ul>
<li>希望复杂的系统提供简单的接口时，从更高层次上操作组合各子系统。</li>
<li>希望减少客户程序与抽象类的实现部分之间的依赖性，可以入facade层。</li>
</ul>


<hr />

<h2>Flyweight（享元）模式</h2>

<h3>定义</h3>

<p>运用共享技术有效的支持大量的细粒度对象。</p>

<h3>结构</h3>

<p><img src="/images/DPython/flyweight.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>Flyweight：描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。</li>
<li>ConcreteFlyweight：实现Flyweight接口，并为内部状态增加存储空间，其对象必须是可共享的。</li>
<li>UnsharedConcreteFlyweight：Flyweight接口使共享成为可能，但是并不强制共享。该类指那些不需要被共享的子类。</li>
<li>FlyweightFactory：创建并管理Flyweight对象，确保合理的共享Flyweight对象。</li>
<li>client：维持一个对Flyweight的引用，计算或存储一个或多个flyweight的内部状态。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>flyweight.py</p>

<pre><code>  class Flyweight(object):
      def operation(self, extrainsicstate):
          pass

  class ConcreteFlyweight(Flyweight):
      def operation(self, extrainsicstate):
          print "concrete flyweight" + str(extrainsicstate)

  class UnsharedConcreteFlyweight(Flyweight):
      def operation(self, extrainsicstate):
          print "unshared concrete flyweight" + str(extrainsicstate)

  class FlyweightFactory(object):
      def __init__(self):
          self.flyweights = {}

      def get_flyweight(self, key):
          if self.flyweights.has_key(key):
              return self.flyweights[key]
          else:
              fw = ConcreteFlyweight()
              self.flyweights[key] = fw
              return fw
</code></pre></li>
<li><p>client.py</p>

<pre><code>  from flyweight import *

  extrinsicstate = 20
  f = FlyweightFactory()
  fx = f.get_flyweight("x")
  fx.operation(extrinsicstate-1)

  fy = f.get_flyweight("y")
  fy.operation(extrinsicstate-1)

  uf = UnsharedConcreteFlyweight()
  uf.operation(extrinsicstate-2)
</code></pre></li>
</ul>


<h3>适用性</h3>

<ul>
<li>当一个程序使用了大量的对象，造成很大的存储开销时。</li>
<li>对象的大多数状态都可变为外部状态，如果删除外部对象则可使用较少的共享对象取代很多组对象。</li>
</ul>


<hr />

<h2>Proxy（代理）模式</h2>

<h3>定义</h3>

<p>为其他对象提供一种代理以控制对这个对象的访问。</p>

<h3>结构</h3>

<p><img src="/images/DPython/proxy.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>Proxy：保存一个引用，使得代理可以访问实体，提供与Subject相同的接口，代理就可以代替实体，控制对实体的新建、存储、删除。</li>
<li>Subject：定义Proxy与RealSubject的公用接口。</li>
<li>RealSubject：实体类。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p><code>proxy.py</code></p>

<pre><code>  class Subject(object):
      def operation(self):
          pass

  class RealSubject(Subject):
      def operation(self):
          print "real subject operation"

  class Proxy(Subject):
      def __init__(self):
          self.rs = RealSubject()

      def operation(self):
          self.rs.operation()
</code></pre></li>
<li><p><code>client.py</code></p>

<pre><code>  from proxy import *

  proxy = Proxy()
  proxy.operation() 
</code></pre></li>
</ul>


<h3>适用性</h3>

<ul>
<li>远程代理：为一个在不同地址空间的对象提供局部代表。</li>
<li>虚代理：需要创建开销很大的对象时，通过代理存放真实对象。</li>
<li>保护代理：控制对原来对象的访问。</li>
<li>智能指引：代理处理附加操作</li>
</ul>


<hr />

<h2>几种结构型模式的讨论</h2>

<ul>
<li>Adapter和Bridge模式都给另一对象提供了一定程度上的间接性，有利于系统的灵活性。二者不同在于Adapter主要解决已有接口之间的不匹配问题，而bridge模式则是对抽象接口和实现部分进行桥接。</li>
<li>Composite和Decorator模式具有类似的结构图，都基于递归组合来组织可变数目的对象。但Decorator旨在不需要生成子类即可给对象添加职责；而composite则旨在构造类，重点在表示不在装饰。</li>
</ul>


<hr />

<h3>源码</h3>

<p>欢迎大家去github上查看<a href="https://github.com/easypi/DPython.git">本项目</a>的所有源文件。</p>

<h3>参考</h3>

<ul>
<li><a href="http://book.douban.com/subject/1052241/">设计模式-可复用面向对象软件的基础</a></li>
<li><a href="http://book.douban.com/subject/2334288/">大话设计模式</a></li>
<li><a href="http://docs.linuxtone.org/ebooks/Python/Thinking_In_Python.pdf">Thinking in python</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：Python语言实现之创建型模式]]></title>
    <link href="http://easypi.github.com/blog/2013/03/15/design-pattern-in-python-creational-ones/"/>
    <updated>2013-03-15T20:45:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/03/15/design-pattern-in-python-creational-ones</id>
    <content type="html"><![CDATA[<p>本文介绍设计模式中的创建型模式，包括简单工厂模式、工厂方法模式、抽象工厂模式、生成器模式、原型模式和单例模式。说明了每种模式的定义、结构、特点，并给出了使用python语言实现的代码。</p>

<!-- more -->


<h2>simple factory 模式</h2>

<h3>定义</h3>

<p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，是由一个工厂对象决定创建出哪一种产品类的实例。</p>

<h3>结构</h3>

<p><img src="/images/DPython/simplefactory.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象产品（Product）：所创建产品的父类，用于描述所有实例具有的公共接口</li>
<li>具体产品（ConcreteProduct）：所创建产品的具体类，实现公共接口，产生具体实例。</li>
<li>简单工厂（SimpleFactory）：负责实现创建实例的内部逻辑逻辑，直接被外部调用，创建所需产品对象</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>抽象产品（<code>product.py</code>）</p>

<pre><code>  class Product(object):
      """a base class to define common interfaces"""
      def operate(self):
          pass
</code></pre></li>
<li><p>具体产品（<code>concrete_product_1.py</code> &amp; <code>concrete_product_2.py</code>）</p>

<pre><code>  from product import *
  class ConcreteProduct_1(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_1"

  from product import *
  class ConcreteProduct_2(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_2"
</code></pre></li>
<li><p>简单工厂（<code>simple_factory.py</code>）</p>

<pre><code>  from concrete_product_1 import *
  from concrete_product_2 import *

  class SimpleFactory(object):
      """SimpleFactory to create concrete pruduct"""
      def create(self,option):
          if option == "product 1":
              return ConcreteProduct_1()
          elif option == "product 2":
              return ConcreteProduct_2()
          else: 
              return None
</code></pre></li>
<li><p>客户端使用示例（<code>use_sim_fac.py</code>）</p>

<pre><code>  from simple_factory import SimpleFactory

  fac = SimpleFactory()
  product = fac.create("product 2")
  if product != None:
      product.operate()
</code></pre></li>
</ul>


<h3>优缺点</h3>

<ul>
<li>优点：简单工厂模式中，工厂类实现逻辑，根据外界信息决定创建哪个具体类的实例，避免客户端程序直接创建具体实例。</li>
<li>缺点：工厂类是该模式的核心，承担了太重要的角色，工厂类能够正常工作影响全部逻辑。此外，如需增加和扩展业务时需更改工厂类，违反开放-封闭的原则。</li>
</ul>


<hr />

<h2>factory method 模式</h2>

<h3>定义</h3>

<p>工厂方法模式又叫做虚构造器，它定义一个用于创建对象的接口，让子类决定实例化哪一个对象。该模式使一个类的实例化延迟到其子类。</p>

<h3>结构</h3>

<p><img src="/images/DPython/factorymethod.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象产品（Product）：所创建产品的父类，用于描述所有实例具有的公共接口</li>
<li>具体产品（ConcreteProduct）：所创建产品的具体类，实现公共接口，产生具体实例。</li>
<li>抽象创建者（Creator）：声明工厂方法，返回Product类型对象。</li>
<li>具体创建者（ConcreteCreator）：定义具体工厂方法，返回具体ConcreteProduct实例。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>产品类 （<code>product.py</code>）</p>

<pre><code>  #  abstract product
  class Product(object):
      """a base class to define common interfaces"""
      def operate(self):
          pass

  # concrete product
  class ConcreteProduct_1(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_1"

  class ConcreteProduct_2(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_2"
</code></pre></li>
<li><p>创建者类 （<code>creator.py</code>）</p>

<pre><code>  from product import *

  # abstract creator
  class Creator(object):
      """a base creator to define factory method"""
      def create(self):
          pass

  # concrete creator
  class ConcreteCreator_1(Creator):
      """ a concrete creator to implement factory method"""
      def create(self):
          return ConcreteProduct_1()

  class ConcreteCreator_2(Creator):
      """ a concrete creator to implement factory method"""
      def create(self):
          return ConcreteProduct_2()
</code></pre></li>
<li><p>客户端 （<code>client.py</code>）</p>

<pre><code>  import random
  from product import *
  from creator import *

  # choice concrete creator manually
  mycreator = ConcreteCreator_1()
  myproduct = mycreator.create()
  myproduct.operate()

  # choice concrete creator randomly
  def genefac(n):
      for i in range(n):
          yield random.choice(Creator.__subclasses__())

  mycreators = [i() for i in genefac(10)]
  myproducts = [i.create() for i in mycreators]

  for i in myproducts:
      i.operate()
</code></pre></li>
</ul>


<h3>优缺点</h3>

<ul>
<li>优点：工厂方法模式将简单工厂中工厂类的逻辑交由客户端，客户端选择具体工厂类进行具体产品的实例化，当增加新的产品时，不需要更改抽象工厂类，只需实现新的具体工厂类即可，封装性和可扩展性好</li>
<li>缺点：当应用本身逻辑简单时，相对于简单工厂方法，其编码较多，额外开销大。</li>
</ul>


<hr />

<h2>abstract factory 模式</h2>

<h3>定义</h3>

<p>抽象工厂模式，又叫kit模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。适用于具有多个产品系列的应用情况。</p>

<h3>结构</h3>

<p><img src="/images/DPython/abstractfactory.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象工厂（AbstractFactory）：声明一个创建抽象对象产品的操作接口。</li>
<li>具体工厂（ConcreteFactory）: 实现创建具体产品对象的操作</li>
<li>抽象产品（AbstractProduct）：为一类产品对象声明接口</li>
<li>具体产品（ConcreteProduct）：定义一个将被相应工厂创建的产品对象，实现抽象产品接口</li>
<li>客户端（Client）：仅使用由抽象工厂和抽象产品声明的接口。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>产品类(<code>product.py</code>)</p>

<pre><code>  # abstract product A

  class AbstractProductA(object):
      def operate(self):
          pass

  # concrete product A

  class ConcreteProductA1(AbstractProductA):
      def operate(self):
          print "operate by ConcreteProductA1"

  class ConcreteProductA2(AbstractProductA):
      def operate(self):
          print "operate by ConcreteProductA2"

  # abstract product B

  class AbstractProductB(object):
      def operate(self):
          pass

  # concrete product B

  class ConcreteProductB1(AbstractProductB):
      def operate(self):
          print "operate by ConcreteProductB1"

  class ConcreteProductB2(AbstractProductB):
      def operate(self):
          print "operate by ConcreteProductB2"
</code></pre></li>
<li><p>工厂类(<code>factory.py</code>)</p>

<pre><code>  from product import *

  # abstract factory

  class AbstractFactory(object):
      def create_product_a(self):
          pass
      def create_product_b(self):
          pass

  # concrete factory

  class ConcreteFactory1(AbstractFactory):
      def create_product_a(self):
          return ConcreteProductA1()
      def create_product_b(self):
          return ConcreteProductB1()

  class ConcreteFactory2(AbstractFactory):
      def create_product_a(self):
          return ConcreteProductA2()
      def create_product_b(self):
          return ConcreteProductB2()
</code></pre></li>
<li><p>客户端(<code>client.py</code>)</p>

<pre><code>  import random
  from product import *
  from factory import *

  # choice concrete factory manually
  fac = ConcreteFactory1()
  prod = fac.create_product_a()
  prod.operate()


  # choice concrete factory randomly
  def genfac(n):
      for i in range(n):
          yield random.choice(AbstractFactory.__subclasses__())

  facs = [i() for i in genfac(10)]


  prods = []
  [prods.extend([i.create_product_a(), i.create_product_b()]) for i in facs]

  for i in prods:
      i.operate()
</code></pre></li>
</ul>


<h3>优缺点</h3>

<ul>
<li>优点：该模式方便改变产品系列，只改变具体工厂就可以配置不同的产品系列。</li>
<li>缺点：使用该模式增加新的产品时，由于抽象工厂定义了所有可生产产品的集合，因此需要更改所有工厂类以实现增加产品的目的，开销较大。</li>
</ul>


<hr />

<h2>builder 模式</h2>

<h3>定义</h3>

<p>生成器模式将一个复杂对象的创建过程与它的表示分离，使得同样的创建过程可以创建不同的表示。</p>

<h3>结构</h3>

<p><img src="/images/DPython/builder.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>具体产品（Product）：被构造的具体产品，定义组成部件的类，由ConcreteBuilder调用接口进行具体装配。</li>
<li>抽象生成器（Builder）：为创建具体产品对象的各个部件指定抽象接口。</li>
<li>具体生成器（ConcreteBuilder）：定义抽象生成器的创建部件的接口，并提供一个检索具体产品的接口。</li>
<li>指挥者（Director）：构建使用生成器接口的对象，定义构建的标准流程。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>产品类(<code>product.py</code>)</p>

<pre><code>  class Product(object):
      def __init__(self):
          self.parts = "I hava these parts: "

      def add(self, part):
          self.parts += part

      def show(self):
          print self.parts
</code></pre></li>
<li><p>生成器类（<code>builder.py</code>）</p>

<pre><code>  from product import *

  # abstract builder
  class Builder(object):
      def build_part_a(self):
          pass
      def build_part_b(self):
          pass

  # concrete builder
  class ConcreteBuilder1(Builder):
      def __init__(self):
          self.product = Product()

      def build_part_a(self):
          self.product.add("1_part_a, ")

      def build_part_b(self):
          self.product.add("1_part_b, ")

      def get_result(self):
          return self.product

  class ConcreteBuilder2(Builder):
      def __init__(self):
          self.product = Product()

      def build_part_a(self):
          self.product.add("2_part_a, ")

      def build_part_b(self):
          self.product.add("2_part_b, ")

      def get_result(self):
          return self.product
</code></pre></li>
<li><p>指挥者类(<code>director.py</code>)</p>

<pre><code>  from builder import *

  class Director(object):
      def construct(self, builder):
          builder.build_part_a()
          builder.build_part_b()
</code></pre></li>
<li><p>客户端(<code>client.py</code>)</p>

<pre><code>  from builder import *
  from director import *

  mydirector = Director()
  mybuilder1 = ConcreteBuilder1()
  mybuilder2 = ConcreteBuilder2()

  mydirector.construct(mybuilder1)
  mydirector.construct(mybuilder2)

  prod1 = mybuilder1.get_result()
  prod2 = mybuilder2.get_result()

  prod1.show()
  prod2.show()
</code></pre></li>
</ul>


<h3>适用性</h3>

<p>该模式适用于当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时，且允许被构造的对象有不同的表示时。它可以使构造代码与表示代码分离，通过传递不同的生成器可以改变不同的表示。相比于抽象工厂模式，二者均可建立复杂的产品对象，但侧重点不同，生成器模式侧重一步一步构造复杂产品，而抽象工厂则侧重多个系列产品（复杂或是简单的）对象的构造。</p>

<hr />

<h2>prototype 模式</h2>

<h3>定义</h3>

<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>

<h3>结构</h3>

<p><img src="/images/DPython/prototype.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象原型（Prototype）：声明一个克隆自身的接口。</li>
<li>具体原型（ConcretePrototype）：实现克隆自身的操作。</li>
<li>客户端（Client）：让一个原型克隆自身返回一个新的对象。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>原型类（<code>prototype.py</code>）</p>

<pre><code>  import copy

  # abstract prototype
  class Prototype(object):
      def clone(self):
          pass

  # concrete prototype
  class ConcretePrototype1(Prototype):
      def clone(self):
          return copy.copy(self)

  class ConcretePrototype2(Prototype):
      def clone(self):
          return copy.copy(self)
</code></pre></li>
<li><p>客户端（<code>client.py</code>）</p>

<pre><code>  from prototype import *

  p1 = ConcretePrototype1()
  c1 = p1.clone()
</code></pre></li>
</ul>


<h3>适用性</h3>

<p>该模式的优点在于可以从一个对象再创建另外一个可以定制的对象，且不需要知道具体的创建过程。可以实现运行时刻指定实例化类，此外还具有比手动创建所有实例更方便的优点。</p>

<hr />

<h2>singleton 模式</h2>

<h3>定义</h3>

<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>

<h3>结构</h3>

<p><img src="/images/DPython/singleton.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>单例类（Singleton）：定义一个get_instance方法，允许客户端访问它的唯一实例。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>单例类（<code>singleton.py</code>）</p>

<pre><code>  class Singleton(object):
      instance = None

      def __init__(self):
          pass

      @staticmethod
      def get_instance():
          if Singleton.instance is None:
              Singleton.instance = Singleton()

          return Singleton.instance
</code></pre></li>
<li><p>客户端（<code>client.py</code>）</p>

<pre><code>  from singleton import *

  s1 = Singleton.get_instance()
  s2 = Singleton.get_instance()

  if s1 is s2:
      print "in singleton pattern"
</code></pre></li>
</ul>


<h3>适用性</h3>

<p>单例模式保证了类只有一个实例，且可以从一个众所周知的访问点访问它。</p>

<hr />

<h3>源码</h3>

<p>欢迎大家去github上查看<a href="https://github.com/easypi/DPython.git">本项目</a>的所有源文件。</p>

<h3>参考</h3>

<ul>
<li><a href="http://book.douban.com/subject/1052241/">设计模式-可复用面向对象软件的基础</a></li>
<li><a href="http://book.douban.com/subject/2334288/">大话设计模式</a></li>
<li><a href="http://docs.linuxtone.org/ebooks/Python/Thinking_In_Python.pdf">Thinking in python</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
