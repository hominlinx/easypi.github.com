<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: note | easypi's blog]]></title>
  <link href="http://easypi.github.com/blog/categories/note/atom.xml" rel="self"/>
  <link href="http://easypi.github.com/"/>
  <updated>2013-03-15T22:16:12+08:00</updated>
  <id>http://easypi.github.com/</id>
  <author>
    <name><![CDATA[厚之成]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：Python语言实现之创建型模式]]></title>
    <link href="http://easypi.github.com/blog/2013/03/15/design-pattern-in-python-creational-ones/"/>
    <updated>2013-03-15T20:45:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/03/15/design-pattern-in-python-creational-ones</id>
    <content type="html"><![CDATA[<p>本文介绍设计模式中的创建型模式，包括简单工厂模式、工厂方法模式、抽象工厂模式、生成器模式、原型模式和单例模式。说明了每种模式的定义、结构、特点，并给出了使用python语言实现的代码。</p>

<!-- more -->


<h2>simple factory 模式</h2>

<h3>定义</h3>

<p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，是由一个工厂对象决定创建出哪一种产品类的实例。</p>

<h3>结构</h3>

<p><img src="/images/DPython/simplefactory.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象产品（Product）：所创建产品的父类，用于描述所有实例具有的公共接口</li>
<li>具体产品（ConcreteProduct）：所创建产品的具体类，实现公共接口，产生具体实例。</li>
<li>简单工厂（SimpleFactory）：负责实现创建实例的内部逻辑逻辑，直接被外部调用，创建所需产品对象</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>抽象产品（<code>product.py</code>）</p>

<pre><code>  class Product(object):
      """a base class to define common interfaces"""
      def operate(self):
          pass
</code></pre></li>
<li><p>具体产品（<code>concrete_product_1.py</code> &amp; <code>concrete_product_2.py</code>）</p>

<pre><code>  from product import *
  class ConcreteProduct_1(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_1"

  from product import *
  class ConcreteProduct_2(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_2"
</code></pre></li>
<li><p>简单工厂（<code>simple_factory.py</code>）</p>

<pre><code>  from concrete_product_1 import *
  from concrete_product_2 import *

  class SimpleFactory(object):
      """SimpleFactory to create concrete pruduct"""
      def create(self,option):
          if option == "product 1":
              return ConcreteProduct_1()
          elif option == "product 2":
              return ConcreteProduct_2()
          else: 
              return None
</code></pre></li>
<li><p>客户端使用示例（<code>use_sim_fac.py</code>）</p>

<pre><code>  from simple_factory import SimpleFactory

  fac = SimpleFactory()
  product = fac.create("product 2")
  if product != None:
      product.operate()
</code></pre></li>
</ul>


<h3>优缺点</h3>

<ul>
<li>优点：简单工厂模式中，工厂类实现逻辑，根据外界信息决定创建哪个具体类的实例，避免客户端程序直接创建具体实例。</li>
<li>缺点：工厂类是该模式的核心，承担了太重要的角色，工厂类能够正常工作影响全部逻辑。此外，如需增加和扩展业务时需更改工厂类，违反开放-封闭的原则。</li>
</ul>


<hr />

<h2>factory method 模式</h2>

<h3>定义</h3>

<p>工厂方法模式又叫做虚构造器，它定义一个用于创建对象的接口，让子类决定实例化哪一个对象。该模式使一个类的实例化延迟到其子类。</p>

<h3>结构</h3>

<p><img src="/images/DPython/factorymethod.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象产品（Product）：所创建产品的父类，用于描述所有实例具有的公共接口</li>
<li>具体产品（ConcreteProduct）：所创建产品的具体类，实现公共接口，产生具体实例。</li>
<li>抽象创建者（Creator）：声明工厂方法，返回Product类型对象。</li>
<li>具体创建者（ConcreteCreator）：定义具体工厂方法，返回具体ConcreteProduct实例。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>产品类 （<code>product.py</code>）</p>

<pre><code>  #  abstract product
  class Product(object):
      """a base class to define common interfaces"""
      def operate(self):
          pass

  # concrete product
  class ConcreteProduct_1(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_1"

  class ConcreteProduct_2(Product):
      """a concrete product class to implement common interfaces"""
      def operate(self):
          print "operation implemented by ConcreteProduct_2"
</code></pre></li>
<li><p>创建者类 （<code>creator.py</code>）</p>

<pre><code>  from product import *

  # abstract creator
  class Creator(object):
      """a base creator to define factory method"""
      def create(self):
          pass

  # concrete creator
  class ConcreteCreator_1(Creator):
      """ a concrete creator to implement factory method"""
      def create(self):
          return ConcreteProduct_1()

  class ConcreteCreator_2(Creator):
      """ a concrete creator to implement factory method"""
      def create(self):
          return ConcreteProduct_2()
</code></pre></li>
<li><p>客户端 （<code>client.py</code>）</p>

<pre><code>  import random
  from product import *
  from creator import *

  # choice concrete creator manually
  mycreator = ConcreteCreator_1()
  myproduct = mycreator.create()
  myproduct.operate()

  # choice concrete creator randomly
  def genefac(n):
      for i in range(n):
          yield random.choice(Creator.__subclasses__())

  mycreators = [i() for i in genefac(10)]
  myproducts = [i.create() for i in mycreators]

  for i in myproducts:
      i.operate()
</code></pre></li>
</ul>


<h3>优缺点</h3>

<ul>
<li>优点：工厂方法模式将简单工厂中工厂类的逻辑交由客户端，客户端选择具体工厂类进行具体产品的实例化，当增加新的产品时，不需要更改抽象工厂类，只需实现新的具体工厂类即可，封装性和可扩展性好</li>
<li>缺点：当应用本身逻辑简单时，相对于简单工厂方法，其编码较多，额外开销大。</li>
</ul>


<hr />

<h2>abstract factory 模式</h2>

<h3>定义</h3>

<p>抽象工厂模式，又叫kit模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。适用于具有多个产品系列的应用情况。</p>

<h3>结构</h3>

<p><img src="/images/DPython/abstractfactory.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象工厂（AbstractFactory）：声明一个创建抽象对象产品的操作接口。</li>
<li>具体工厂（ConcreteFactory）: 实现创建具体产品对象的操作</li>
<li>抽象产品（AbstractProduct）：为一类产品对象声明接口</li>
<li>具体产品（ConcreteProduct）：定义一个将被相应工厂创建的产品对象，实现抽象产品接口</li>
<li>客户端（Client）：仅使用由抽象工厂和抽象产品声明的接口。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>产品类(<code>product.py</code>)</p>

<pre><code>  # abstract product A

  class AbstractProductA(object):
      def operate(self):
          pass

  # concrete product A

  class ConcreteProductA1(AbstractProductA):
      def operate(self):
          print "operate by ConcreteProductA1"

  class ConcreteProductA2(AbstractProductA):
      def operate(self):
          print "operate by ConcreteProductA2"

  # abstract product B

  class AbstractProductB(object):
      def operate(self):
          pass

  # concrete product B

  class ConcreteProductB1(AbstractProductB):
      def operate(self):
          print "operate by ConcreteProductB1"

  class ConcreteProductB2(AbstractProductB):
      def operate(self):
          print "operate by ConcreteProductB2"
</code></pre></li>
<li><p>工厂类(<code>factory.py</code>)</p>

<pre><code>  from product import *

  # abstract factory

  class AbstractFactory(object):
      def create_product_a(self):
          pass
      def create_product_b(self):
          pass

  # concrete factory

  class ConcreteFactory1(AbstractFactory):
      def create_product_a(self):
          return ConcreteProductA1()
      def create_product_b(self):
          return ConcreteProductB1()

  class ConcreteFactory2(AbstractFactory):
      def create_product_a(self):
          return ConcreteProductA2()
      def create_product_b(self):
          return ConcreteProductB2()
</code></pre></li>
<li><p>客户端(<code>client.py</code>)</p>

<pre><code>  import random
  from product import *
  from factory import *

  # choice concrete factory manually
  fac = ConcreteFactory1()
  prod = fac.create_product_a()
  prod.operate()


  # choice concrete factory randomly
  def genfac(n):
      for i in range(n):
          yield random.choice(AbstractFactory.__subclasses__())

  facs = [i() for i in genfac(10)]


  prods = []
  [prods.extend([i.create_product_a(), i.create_product_b()]) for i in facs]

  for i in prods:
      i.operate()
</code></pre></li>
</ul>


<h3>优缺点</h3>

<ul>
<li>优点：该模式方便改变产品系列，只改变具体工厂就可以配置不同的产品系列。</li>
<li>缺点：使用该模式增加新的产品时，由于抽象工厂定义了所有可生产产品的集合，因此需要更改所有工厂类以实现增加产品的目的，开销较大。</li>
</ul>


<hr />

<h2>builder 模式</h2>

<h3>定义</h3>

<p>生成器模式将一个复杂对象的创建过程与它的表示分离，使得同样的创建过程可以创建不同的表示。</p>

<h3>结构</h3>

<p><img src="/images/DPython/builder.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>具体产品（Product）：被构造的具体产品，定义组成部件的类，由ConcreteBuilder调用接口进行具体装配。</li>
<li>抽象生成器（Builder）：为创建具体产品对象的各个部件指定抽象接口。</li>
<li>具体生成器（ConcreteBuilder）：定义抽象生成器的创建部件的接口，并提供一个检索具体产品的接口。</li>
<li>指挥者（Director）：构建使用生成器接口的对象，定义构建的标准流程。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>产品类(<code>product.py</code>)</p>

<pre><code>  class Product(object):
      def __init__(self):
          self.parts = "I hava these parts: "

      def add(self, part):
          self.parts += part

      def show(self):
          print self.parts
</code></pre></li>
<li><p>生成器类（<code>builder.py</code>）</p>

<pre><code>  from product import *

  # abstract builder
  class Builder(object):
      def build_part_a(self):
          pass
      def build_part_b(self):
          pass

  # concrete builder
  class ConcreteBuilder1(Builder):
      def __init__(self):
          self.product = Product()

      def build_part_a(self):
          self.product.add("1_part_a, ")

      def build_part_b(self):
          self.product.add("1_part_b, ")

      def get_result(self):
          return self.product

  class ConcreteBuilder2(Builder):
      def __init__(self):
          self.product = Product()

      def build_part_a(self):
          self.product.add("2_part_a, ")

      def build_part_b(self):
          self.product.add("2_part_b, ")

      def get_result(self):
          return self.product
</code></pre></li>
<li><p>指挥者类(<code>director.py</code>)</p>

<pre><code>  from builder import *

  class Director(object):
      def construct(self, builder):
          builder.build_part_a()
          builder.build_part_b()
</code></pre></li>
<li><p>客户端(<code>client.py</code>)</p>

<pre><code>  from builder import *
  from director import *

  mydirector = Director()
  mybuilder1 = ConcreteBuilder1()
  mybuilder2 = ConcreteBuilder2()

  mydirector.construct(mybuilder1)
  mydirector.construct(mybuilder2)

  prod1 = mybuilder1.get_result()
  prod2 = mybuilder2.get_result()

  prod1.show()
  prod2.show()
</code></pre></li>
</ul>


<h3>适用性</h3>

<p>该模式适用于当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时，且允许被构造的对象有不同的表示时。它可以使构造代码与表示代码分离，通过传递不同的生成器可以改变不同的表示。相比于抽象工厂模式，二者均可建立复杂的产品对象，但侧重点不同，生成器模式侧重一步一步构造复杂产品，而抽象工厂则侧重多个系列产品（复杂或是简单的）对象的构造。</p>

<hr />

<h2>prototype 模式</h2>

<h3>定义</h3>

<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>

<h3>结构</h3>

<p><img src="/images/DPython/prototype.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>抽象原型（Prototype）：声明一个克隆自身的接口。</li>
<li>具体原型（ConcretePrototype）：实现克隆自身的操作。</li>
<li>客户端（Client）：让一个原型克隆自身返回一个新的对象。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>原型类（<code>prototype.py</code>）</p>

<pre><code>  import copy

  # abstract prototype
  class Prototype(object):
      def clone(self):
          pass

  # concrete prototype
  class ConcretePrototype1(Prototype):
      def clone(self):
          return copy.copy(self)

  class ConcretePrototype2(Prototype):
      def clone(self):
          return copy.copy(self)
</code></pre></li>
<li><p>客户端（<code>client.py</code>）</p>

<pre><code>  from prototype import *

  p1 = ConcretePrototype1()
  c1 = p1.clone()
</code></pre></li>
</ul>


<h3>适用性</h3>

<p>该模式的优点在于可以从一个对象再创建另外一个可以定制的对象，且不需要知道具体的创建过程。可以实现运行时刻指定实例化类，此外还具有比手动创建所有实例更方便的优点。</p>

<hr />

<h2>singleton 模式</h2>

<h3>定义</h3>

<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>

<h3>结构</h3>

<p><img src="/images/DPython/singleton.png" alt="UML图" /></p>

<h3>参与者</h3>

<ul>
<li>单例类（Singleton）：定义一个get_instance方法，允许客户端访问它的唯一实例。</li>
</ul>


<h3>代码实现</h3>

<ul>
<li><p>单例类（<code>singleton.py</code>）</p>

<pre><code>  class Singleton(object):
      instance = None

      def __init__(self):
          pass

      @staticmethod
      def get_instance():
          if Singleton.instance is None:
              Singleton.instance = Singleton()

          return Singleton.instance
</code></pre></li>
<li><p>客户端（<code>client.py</code>）</p>

<pre><code>  from singleton import *

  s1 = Singleton.get_instance()
  s2 = Singleton.get_instance()

  if s1 is s2:
      print "in singleton pattern"
</code></pre></li>
</ul>


<h3>适用性</h3>

<p>单例模式保证了类只有一个实例，且可以从一个众所周知的访问点访问它。</p>

<hr />

<h3>源码</h3>

<p>欢迎大家去github上查看<a href="https://github.com/easypi/DPython.git">本项目</a>的所有源文件。</p>

<h3>参考</h3>

<ul>
<li><a href="http://book.douban.com/subject/1052241/">设计模式-可复用面向对象软件的基础</a></li>
<li><a href="http://book.douban.com/subject/2334288/">大话设计模式</a></li>
<li><a href="http://docs.linuxtone.org/ebooks/Python/Thinking_In_Python.pdf">Thinking in python</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaEE学习之Spring技术]]></title>
    <link href="http://easypi.github.com/blog/2013/02/27/javaee-learning-spring/"/>
    <updated>2013-02-27T17:19:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/02/27/javaee-learning-spring</id>
    <content type="html"><![CDATA[<p>Spring框架是一种从实际开发中抽取出来的框架，提供了一种模板的设计哲学，这些模板完成了大量的通用步骤，开发者只需实现特定应用有关的步骤。Spring提供了一种一站式的解决方案，贯穿表现层，业务层和持久层等，以高度的开放性将已有的框架进行整合。</p>

<!-- more -->


<h2>Spring框架使用流程</h2>

<h3>0. 为web应用添加Spring支持</h3>

<p>将Spring项目下的dist路径下的全部jar包和spring-framework-v复制到WEB-INF\lib路径下，即可在web应用中使用Spring框架。</p>

<h3>1. 编写主程序初始化Spring容器</h3>

<pre><code>package hou;

import PersonService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringTest
{
    public static void main(String[] args)
    {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("bean.xml");
        System.out.println(ctx);
        PersonService p = ctx.getBean("personService" , PersonService.class);
        p.info();   
    }
}
</code></pre>

<h3>2. 编写被Spring容器管理的bean</h3>

<pre><code>public class PersonService
{
    private String name;

    public void setName(String name)
    {
        this.name = name;
    }
    public void info()
    {
        System.out.println("名字"+ name);
    }
}
</code></pre>

<h3>3. 将bean类部署到Spring容器中，通过配置文件</h3>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.springframework.org/schema/beans"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
    &lt;!-- 将PersonService类部署成Spring容器中的Bean  --&gt;
    &lt;bean id="personService" class="PersonService"&gt;
        &lt;property name="name" value="wawa"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>通过以上的简单例子，可以发现Spring容器的一个作用，即IoC（控制反转），就是说Spring容器可以创建bean对象，并通过配置文件设置实例的属性值。这是一种通过Spring容器注入设置实例属性值的方法。</p>

<h2>Spring框架的核心机制</h2>

<p>Spring实现IoC的核心机制是依赖注入。通常当一个调用者的java实例需要另一个被调用者的java实例时，需要调用者来创建被调用者的实例; 而在依赖注入中，创建工作由Spring容器执行，而后注入到调用者中，实现动态管理各个实例。</p>

<h2>参考</h2>

<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaEE学习之Hibernate技术]]></title>
    <link href="http://easypi.github.com/blog/2013/02/27/javaee-learning-hibernate/"/>
    <updated>2013-02-27T16:05:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/02/27/javaee-learning-hibernate</id>
    <content type="html"><![CDATA[<p>由于目前主流的数据库依然是关系数据库，而Java语言是面向对象的编程语言，二者之间发展的不协调导致二者结合使用时非常麻烦。为了解决这种问题，对象/关系数据库映射（ORM）这种规范完成了面向对象语言与关系数据库之间的映射。当使用了ORM框架以后就可以使用面向对象的方法来操作持久化对象，而ORM框架将这些操作转换为底层的SQL操作。Hibernate就是这样一种ORM工具，由于其开源免费、轻量级封装、可扩展性好等特点成为流行的ORM工具。</p>

<!-- more -->


<h2>Hibernate框架使用流程</h2>

<h3>0. 为web应用添加Hibernate支持</h3>

<p>将下载的hibernate-v.jar和lib路径下的required,bytecode,jpa子目录下的所有jar包添加到应用的类加载路径下，即可使用hibernate。</p>

<h3>1. 开发PO（持久化对象）</h3>

<p>持久化对象可以实现以面向对象的方式进行数据库操作,hibernate中的持久化对象由普通java类和映射文件两部分构成。一个简单的POJO类如下</p>

<pre><code>public class News {
    private Integer id;
    private String title;
    private String content;

    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }
    public void setContent(String content) {
        this.content = content;
    }
}
</code></pre>

<p>为了使这个简单的java类具有持久化操作的能力，Hinernate采用映射文件理解持久化类与数据表之间的对应关系，映射文件为xml格式，内容如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
    &lt;class name="News" table="news_table"&gt;
        &lt;id name="id" type="java.lang.Integer"&gt;
            &lt;column name="id" /&gt;
            &lt;generator class="identity" /&gt;
        &lt;/id&gt;
        &lt;property name="title" type="java.lang.String"&gt;
            &lt;column name="title" /&gt;
        &lt;/property&gt;
        &lt;property name="content" type="java.lang.String"&gt;
            &lt;column name="content" /&gt;
        &lt;/property&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>通过对hibernate-mapping中的class进行配置，即可完成持久化对象的开发。</p>

<h3>2. 编写Hibernate通用配置信息</h3>

<p>对于web应用中连接数据库，以及数据库的配置信息是通用的，通过配置Hibernate的通用信息进行指定要连接的数据库，登录用户名和密码等。该配置通过xml文件完成，内容如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="hibernate.connection.password"&gt;32147&lt;/property&gt;
        &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt;
        &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;
        &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;
        &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;
        &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;   

        &lt;mapping resource="org/crazyit/app/domain/News.hbm.xml"/&gt;

    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>

<h3>3. 编写操作类代码，使用面向对象的方法操作数据库</h3>

<p>在完成Hibernate的配置后，即可使用面行对象的方法来操作数据库了，在此类的方法中实现对数据库的操作有以下几步。</p>

<ol>
<li>获取第二步中的通用配置信息</li>
<li>创建SessionFactory</li>
<li>创建Session</li>
<li>开始事务，用面向对象的方法进行处理，最后提交处理</li>
<li>关闭Session</li>
</ol>


<p>以下代码实现往数据库添加一条信息的功能。</p>

<pre><code>package hou;

import News;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

public class NewsManager {

    public static void main(String[] args)
        throws Exception {
        Configuration conf = new Configuration().configure();
        SessionFactory sf = conf.buildSessionFactory();

        Session sess = sf.openSession();

        Transaction tx = sess.beginTransaction();

        News n = new News();

        n.setTitle("一条信息");
        n.setContent("信息内容");

        sess.save(n);
        tx.commit();
        sess.close();
        sf.close();
    }
}
</code></pre>

<h2>参考</h2>

<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JaveEE学习之Struts2技术]]></title>
    <link href="http://easypi.github.com/blog/2013/02/26/javaee-learning-struts/"/>
    <updated>2013-02-26T15:39:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/02/26/javaee-learning-struts</id>
    <content type="html"><![CDATA[<p>Struts2是一款优秀的MVC框架，具有一系列的优点使其具有巨大的吸引力。这些优点包括：允许使用普通java对象作为Action，并且降低了与Servlet API的耦合，更容易测试;支持更多的视图技术;提供良好的可扩展性，更强大的输入校验功能;整合Ajax支持等。本文介绍简单的Struts2应用，来对其进行了解。</p>

<!-- more -->


<h2>Struts2开发应用流程</h2>

<p>这里用一个Struts2开发简单登录处理的web应用来介绍Struts2的开发应用流程</p>

<h3>0. 为web应用添加Struts2支持</h3>

<p>将下载的Struts2中lib文件夹下的 <code>commons-fileupload-v.jar, commons-io-v.jar, freemaker-v.jar, javassit-v.jar, ognl-v.jar, struts2-core-v.jar, xwork-core-v.jar</code>等必须的支持文件（其中<code>-v</code>表示版本号，根据下载不同会有所不同）复制到web应用的<code>WEB-INF\lib</code>路径下，如需其他Struts2的支持，复制相应jar文件即可。</p>

<h3>1. 编辑web应用的web.xml配置文件，配置Struts2的核心filter，并使其拦截相关请求。</h3>

<p>在web.xml配置文件中增加以下内容：</p>

<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<h3>2. 编写处理表单请求的JSP页面来发送POST方式请求，如果是GET方式请求，则此步不进行处理。</h3>

<p>在本登录应用中，需要处理表单请求，编写login.jsp如下</p>

<pre><code>&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;
&lt;%@taglib prefix="s" uri="/struts-tags"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt;
&lt;title&gt;&lt;s:text name="loginPage"/&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;s:form action="login"&gt;
    &lt;s:textfield name="username" key="user"/&gt;
    &lt;s:textfield name="password" key="pass"/&gt;
    &lt;s:submit key="login"/&gt;
&lt;/s:form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在本jsp的编写中声明使用了struts2的标签库，并使用该标签库来编写表单请求代码。</p>

<h3>3. 定义处理用户请求的Action类</h3>

<p>在上述的jsp页面中指定了表单的action为login，因此需要实现一个java类来处理该请求动作。该类通常继承与ActionSupport基类，其代码如下：</p>

<pre><code>import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;

public class LoginAction extends ActionSupport
{
    private String username;
    private String password;

    public String getUsername()
    {
        return username;
    }
    public void setUsername(String username)
    {
        this.username = username;
    }

    public String getPassword()
    {
        return password;
    }
    public void setPassword(String password)
    {
        this.password = password;
    }

    public String execute() throws Exception
    {
        if (getUsername().equals("easypi.github.com")
            &amp;&amp; getPassword().equals("easypi") )
        {
            ActionContext.getContext().getSession()
                .put("user" , getUsername());
        return SUCCESS;
        }
        else
        {
            return ERROR;
        }
    }
}
</code></pre>

<p>该类实现对登录的判断，如果用户名为<code>easypi.github.com</code>，密码为<code>easypi</code>则登录成功，否则失败。</p>

<h3>4. 配置Action以及处理结果和物理视图资源之间的对应关系</h3>

<p>在定义了请求并实现了处理请求action的类之后，需要将请求与action对应起来，用来实现MVC模型。建立struts.xml放置在<code>WEB-INF\classes</code>路径下，使用该文件实现web应用的配置。该文件代码如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="GBK"?&gt;
&lt;!DOCTYPE struts PUBLIC     "-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN"
    "http://struts.apache.org/dtds/struts-2.1.7.dtd"&gt;
&lt;struts&gt;
    &lt;package name="hou" extends="struts-default"&gt;
        &lt;action name="login" class="LoginAction"&gt;   
            &lt;result name="input"&gt;/login.jsp&lt;/result&gt;
            &lt;result name="error"&gt;/error.jsp&lt;/result&gt;
            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;
        &lt;/action&gt;
    &lt;/package&gt;
&lt;/struts&gt;
</code></pre>

<p>其中，将action的login请求使用LoginAction类来进行处理，并可以配置返回结果与物理视图资源之间的对应，如登录成功则进入welcome.jsp页面。</p>

<h3>5. 实现物理视图资源</h3>

<p>使用Struts2开发的最后一步就是实现需要的视图资源，例如welcome.jsp, error.jsp等页面。至此则完成了使用Struts2开发web应用的全部流程，也实现了一次完整的请求响应流程。</p>

<h2>Struts2 请求响应流程</h2>

<p>Struts2的开发流程实际是根据请求响应流程而来的，一次请求响应流程如下。</p>

<p><img src="http://ww1.sinaimg.cn/large/a74ecc4cjw1e26usgyzmaj.jpg" alt="Struts2 请求响应流程" /></p>

<p>其中StrutsPrepareAndExecuteFilter称为核心控制器，xxxAction称为业务控制器。通过两级控制器实现解耦，实现xxxAction只处理返回结果，不与物理视图相连，方便代码更改。</p>

<h2>参考</h2>

<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JaveEE学习之Servlet技术]]></title>
    <link href="http://easypi.github.com/blog/2013/01/14/javaEE-learning-servlet/"/>
    <updated>2013-01-14T20:17:00+08:00</updated>
    <id>http://easypi.github.com/blog/2013/01/14/javaEE-learning-servlet</id>
    <content type="html"><![CDATA[<p>JSP的本质就是Servlet，编写JSP将其放入web容器中，web容器将JSP编译为Servlet。 由于作为表现层技术使用时，直接使用Servlet的开发效率低下，因此一般使用如JSP等的表现层技术实现。在MVC规范中，Servlet通常被当作控制器使用，虽然还有很多其他MVC的框架可用，但Servlet作为底层实现，对学习JavaEE技术，了解技术原理是有意义的。本文给出一个简单的符合MVC规范的web应用例子，并使用Servlet作为其中的控制器来学习Servlet的相关技术。</p>

<!-- more -->


<h2>Servlet类介绍</h2>

<p>Servlet类是一个继承自<code>HttpServlet</code>的特殊类，可以用来响应用户的请求。在编写自己的Servlet时最常使用的方法是<code>service()</code>方法，该方法处理客户端的请求。因此，一个Servlet类的典型结构为：</p>

<pre><code>//使用@WebServlet Annotation 配置servlet
@WebServlet(name="firstServlet", urlPatterns={"/firstServlet"})
//Servlet类定义
public class FirstServlet extends HttpServlet
{
    public void service(HttpServletRequest request,
    HttpServletResponse response) 
    throws ServletException,java.io.IOException 
    {
        //相应用户请求代码
    }
}
</code></pre>

<h2>Servlet类配置</h2>

<p>为了使Servlet响应用户请求，还需将Servlet与Web应用配置起来。配置Servlet有两种方法：在web.xml中配置和使用@WebServlet Annotation配置。使用@WebServlet Annotation直接在Java类的编辑中即可实现，不需web.xml，我认为是更好的方法，因此使用该法进行配置。在使用@WebServlet Annotation时，其常用的几个属性如下：</p>

<ul>
<li>name:                  指定该Servlet的名称</li>
<li>urlPatterns/value:     指定该Servlet要处理的url</li>
<li>initParams：           指定该Servlet的参数</li>
<li>loadOnStartup:         指定该Servlet是否为load on startup 的Servlet</li>
</ul>


<h2>Servlet类作为控制器</h2>

<p>在MVC模式中，Model通常由JavaBean来充当，用来实现业务逻辑、数据访问逻辑等; View通常由JSP来充当，用来收集用户的请求参数、将应用处理的结果和状态等返回呈现给用户等; Controller则由Servlet来充当，实现类似调度员的作用，即用户请求发送到Servlet，Servlet调用Model来处理用户请求，并将结果调用JSP呈现给用户。MVC模式通过对三者作用的分工，实现应用的解耦，方便多人协同开发同一个项目。</p>

<p>现在给出一个简单的MVC模式的应用，实现登录的验证。首先给出<code>login.jsp</code>:</p>

<pre><code>&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
请输入用户名和密码
&lt;!-- 登录表单，被提交至一个Servlet --&gt;
&lt;form id="login" method="post" action="login"&gt;
用户名： &lt;input type="text" name="username"/&gt; &lt;br/&gt;
密码：  &lt;input type="password" name="pass" /&gt; &lt;br/&gt;
&lt;input type="submit" value="登录" /&gt; &lt;br/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>然后给出控制器Servlet类<code>LoginServlet.java</code>:</p>

<pre><code>import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.annotation.*;

import java.sql.*;
import java.io.*;

@WebServlet(name="login", urlPatterns={"/login"})

public class LoginServlet extends HttpServlet {

    public void service(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, java.io.IOException 
    {
            String errMsg="";
            //Servlet不输出响应到客户端，因此必须将请求转发
            RequestDispatcher rd;

            //获取请求参数    
            String username =  request.getParameter("username");
            String pass = request.getParameter("pass");
            PrintStream out = new PrintStream(response.getOutputStream());
            //out.println("name" + username);

            try {
                //Servlet 本身不处理业务逻辑，调用JavaBean处理用户请求
                DbDao dd = new DbDao("com.mysql.jdbc.Driver",
                    "jdbc:mysql://localhost:3306/javaee","root","mysql");
                //查询结果集
                ResultSet rs = dd.query("select pass from user_table"
                    + "where name = ?", username);
                if (rs.next()) {

                    //用户名和密码匹配
                    if (rs.getString("pass").equals(pass)) {
                        // 获取session对象
                        HttpSession session = request.getSession(true);
                        //设置session属性，跟踪用户会话状态
                        session.setAttribute("name", username);
                        //获取转发对象
                        rd = request.getRequestDispatcher("/welcome.jsp");
                        rd.forward(request, response);
                    }
                    else {
                        //用户名密码不匹配
                        errMsg += "您的用户名密码不符合，请重试";
                    }
                }
                else {
                    //用户名不存在时
                    errMsg += "您的用户名不存在，请先注册";
                }

            }
            catch (Exception e) {
                out.println(errMsg);
                e.printStackTrace();
            }

            //如果出错，转发到重新登录
            if (errMsg != null &amp;&amp; !errMsg.equals("")) {
                rd = request.getRequestDispatcher("/login.jsp");
                request.setAttribute("err", errMsg);
                rd.forward(request, response);
            }

        }   
}
</code></pre>

<p>最后给出Model类<code>DbDao.java</code>：</p>

<pre><code>import java.sql.*;

public class DbDao {
    private Connection conn;
    private String driver;
    private String url;
    private String username;
    private String pass;

    public DbDao() {}
    public DbDao(String driver, String url, String username, String pass) {
        this.driver = driver;
        this.url = url;
        this.username = username;
        this.pass = pass;
    }
    //各属性的setter和getter方法
    public void setDriver(String driver) {
        this.driver = driver;
    }
    public void setUrl(String url) {
        this.url = url;
    }
    public void setUsername(String username) {
        this.username=username;
    }
    public void setPass(String pass) {
        this.pass = pass;
    }
    public String getDriver() {
        return this.driver;
    }
    public String getUrl() {
        return this.url;
    }
    public String getUsername() {
        return this.username;
    }
    public String getPass() {
        return this.pass;
    }

    //获取数据库连接
    public Connection getConnection() throws Exception{
        if (conn == null) {
            Class.forName(this.driver);
            conn = DriverManager.getConnection(url, username, this.pass);
        }
        return conn;
    }
    // 插入记录
    public boolean insert(String sql, Object... args) throws Exception {
        PreparedStatement pstmt = getConnection().prepareStatement(sql);
        for (int i=0; i&lt;args.length; i++) {
            pstmt.setObject(i+1, args[i]);
        }
        if (pstmt.executeUpdate() != 1) {
            return false;
        }
        return true;
    }
    // 执行查询
    public ResultSet query(String sql, Object... args) throws Exception {
        PreparedStatement pstmt = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; args.length; i++) {
            pstmt.setObject(i+1, args[i]);
        }
        return pstmt.executeQuery();
    }
    //执行修改
    public void moify (String sql, Object... args) throws Exception {
        PreparedStatement pstmt = getConnection().prepareStatement(sql);
        for (int i = 0; i &lt; args.length; i++) {
            pstmt.setObject(i+1, args[i]);
        }
        pstmt.executeUpdate();
        pstmt.close();
    }
    //关闭数据库连接的方法
    public void closeConn() throws Exception {
        if (conn != null &amp;&amp; !conn.isClosed()) {
            conn.close();
        }
    }
}
</code></pre>

<p>至此，一个完整的MVC模式的web应用就完成了，其中JSP充当View，用来提供用户交流界面; Servlet充当控制器, 起调动作用；JavaBean充当模型，处理业务逻辑和数据逻辑。</p>

<h2>Servlet类相关</h2>

<h3>Filter</h3>

<p>Filter可以看作Servlet的加强版，它是一个处理链，典型的使用流程是：使用Filter对用户请求进行预处理，然后将请求交给Servlet进行处理，最后对服务器响应进行后处理。Filter的作用主要有以下几个方面：</p>

<ul>
<li>拦截HttpServletRequest进行预处理，可以修改请求数据，然后交给Servlet处理</li>
<li>拦截HttpServletResponse进行后处理，可以修改Servlet的处理结果，然后作为服务器的响应结果。</li>
</ul>


<p>Filter的使用和Servlet非常类似，包括定义Filter类和配置Filter两步。其中Filter类必须实现<code>javax.servlet.Filter</code>接口，主要功能在<code>doFilter()</code>函数内实现。Filter的配置也可使用@webFilter Annotation进行配置。</p>

<h3>Listener</h3>

<p>Listener完成对web应用内事件的监听和处理，从而允许当web应用内有事件发生时，可以回调事件监听器内的方法。Listener的使用与Servlet类似，分为定义Listener实现类和配置Listener两步。自定义的Listener类根据不同的web应用时间需实现不同的接口，常见的web监听器接口有以下几个：</p>

<ul>
<li>ServletContextListener: 用于监听web应用的启动和关闭</li>
<li>ServletContextAttributerListener: 用于监听ServletContext范围（application）内属性的更改</li>
<li>ServletRequestListener： 用于监听用户请求</li>
<li>ServletRequestAttributerListener: 用于监听ServletRequest范围（request）内属性的更改</li>
<li>ServletSessionListener： 用于监听用户Session的开始和结束</li>
<li>ServletSessionAttributerListener: 用于监听ServletSession范围（session）内属性的更改</li>
</ul>


<h2>参考</h2>

<p><a href="http://book.douban.com/subject/6002664/">轻量级Java EE企业应用实战</a></p>
]]></content>
  </entry>
  
</feed>
